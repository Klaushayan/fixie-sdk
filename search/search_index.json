{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Fixie Developer Portal \ud83e\udd8a Fixie is a platform for building applications using Large Language Models. With Fixie, you can write apps that communicate, in natural language, with one or more Agents that can access individual APIs or sources of data, such as GitHub, Google Calendar, or a database. You can access the Fixie web interface at app.fixie.ai . Using the Fixie SDK allows you to connect your own applications to the Fixie platform, either as a client, or by building custom agents that plug into the platform. To learn more about Fixie, check us out at https://fixie.ai . \ud83d\udd25 Fixie Developer Preview Fixie is currently available as a Developer Preview. During this time, Fixie is free to use, however, there is a limit on the number of queries per user per day. Please check out Fixie Develper Preview for more information. \ud83e\udd14 Need help? The best way to contact us and get support is to join our Discord server . Getting started Verify you can access app.fixie.ai with your Google or GitHub email Install the fixie CLI with pip install fixieai and run fixie auth to ensure your are successfully authenticated Fork the examples repo Choose any of the example agents, cd into the directory, and run fixie agent deploy Test that agent by running fixie console -a username/agent_name and inputting a test query. You can also run fixie console and then @ your specific agent (e.g. @username/agent_name this is the query ) You can also talk to deployed agents directly at app.fixie.ai For local development and testing, you can also run your agent locally with fixie agent serve . This is easier for debugging what\u2019s happening when things go wrong. This will create a tunnel to your local machine. After running serve, open a new terminal window and talk to the agent just like in step 5. Example of query using SDK: import fixieai response = fixieai . query ( \"How many countries start with the letter R ?\" ) print ( response ) Agent Examples Agents are at the heart of the Fixie ecosystem, and we make it easy to build and contribute your own. To get started you can scaffold out a default agent by running: fixie init . For more examples check out Building Fixie Agents and our examples repo . Documentation Check out the links below for more information on how to get started using Fixie. Tutorials Fixie Architecture Overview Agent Quickstart Building Fixie Agents Agent Protocol Reference Fixie CLI Reference Python Client API Python Agent API Fixie GraphQL API Reference","title":"Introduction"},{"location":"#fixie-developer-portal","text":"Fixie is a platform for building applications using Large Language Models. With Fixie, you can write apps that communicate, in natural language, with one or more Agents that can access individual APIs or sources of data, such as GitHub, Google Calendar, or a database. You can access the Fixie web interface at app.fixie.ai . Using the Fixie SDK allows you to connect your own applications to the Fixie platform, either as a client, or by building custom agents that plug into the platform. To learn more about Fixie, check us out at https://fixie.ai . \ud83d\udd25 Fixie Developer Preview Fixie is currently available as a Developer Preview. During this time, Fixie is free to use, however, there is a limit on the number of queries per user per day. Please check out Fixie Develper Preview for more information. \ud83e\udd14 Need help? The best way to contact us and get support is to join our Discord server .","title":"Fixie Developer Portal \ud83e\udd8a"},{"location":"#getting-started","text":"Verify you can access app.fixie.ai with your Google or GitHub email Install the fixie CLI with pip install fixieai and run fixie auth to ensure your are successfully authenticated Fork the examples repo Choose any of the example agents, cd into the directory, and run fixie agent deploy Test that agent by running fixie console -a username/agent_name and inputting a test query. You can also run fixie console and then @ your specific agent (e.g. @username/agent_name this is the query ) You can also talk to deployed agents directly at app.fixie.ai For local development and testing, you can also run your agent locally with fixie agent serve . This is easier for debugging what\u2019s happening when things go wrong. This will create a tunnel to your local machine. After running serve, open a new terminal window and talk to the agent just like in step 5. Example of query using SDK: import fixieai response = fixieai . query ( \"How many countries start with the letter R ?\" ) print ( response )","title":"Getting started"},{"location":"#agent-examples","text":"Agents are at the heart of the Fixie ecosystem, and we make it easy to build and contribute your own. To get started you can scaffold out a default agent by running: fixie init . For more examples check out Building Fixie Agents and our examples repo .","title":"Agent Examples"},{"location":"#documentation","text":"Check out the links below for more information on how to get started using Fixie.","title":"Documentation"},{"location":"#tutorials","text":"Fixie Architecture Overview Agent Quickstart Building Fixie Agents Agent Protocol","title":"Tutorials"},{"location":"#reference","text":"Fixie CLI Reference Python Client API Python Agent API Fixie GraphQL API Reference","title":"Reference"},{"location":"agent-protocol/","text":"Fixie Agent Protocol Fixie Agents can be implemented in any programming language. The Fixie Python Agent API provides a Python SDK that makes it easy to implement Agents in Python, however, it is possible to implement Fixie Agents in any programming language, as long as the Agent code conforms to the following protocol. A Fixie Agent is a program that accepts HTTP requests of two types: An HTTP GET request to the / endpoint, which returns a list of few-shot examples that the Agent supports. An HTTP POST request to the /FUNC endpoint, which returns the result of calling the function FUNC with the parameters specified in the request. Agents can support multiple functions. Few-shot examples Upon receiving an HTTP GET request to the / endpoint, the Agent must return a list of few-shot examples that the Agent supports. The few-shot examples are used to provide examples to the underlying Large Language Model, such as GPT-3, as well as to provide the Fixie Platform information on what kinds of queries this Agent can support. The few-shot examples are returned as a JSON object with the following format: { \"base_prompt\" : \"The base prompt for the few-shot examples.\" , \"few_shots\" : [ \"The first few-shot example.\" , \"The second few-shot example.\" , \"The third few-shot example.\" ] } Each few-shot excample consists of one or more lines, separating by a newline character ( \\n ). The first line of each example must be a sample query, which must start with the prefix Q: . The final line of the few-shot example must be the corresponding answer, which must start with the prefix A: . The few-shot example may contain any number of lines in between the query and answer, representing intermediate outputs from the Large Language Model, as well as responses to the LLM from external functions. Here is an example of a single few-shot example: Q : Generate a random number between 0 and 19. Ask Func [ genrand ] : 0 , 19 Func [ genrand ] says : 17 A : The random number is 17. In this example, the first line represents a sample query that the Agent can support. The second line is the LLM response to receiving this query, which in this case indicates that the Function genrand should be invoked with the input string 0, 19 . The third line is the expected response from the Function genrand , and the final line is the answer to the query. Using the Fixie Python SDK, the values of the base_prompt and few_shots fields are specified by setting the values of the BASE_PROMPT and FEW_SHOTS variables in the Agent code, respectively. Function invocation Upon receiving an HTTP POST request to the /FUNC endpoint, the Agent must return the result of calling the Agent function FUNC with the parameters specified in the body of the HTTP POST request. The body of the POST request will be in the following format: { \"message\" : { \"text\" : \"Argument to function call\" , } } The Agent should invoke the function FUNC , passing in the contents of the JSON object message as the argument to the function call. The result of the function call should be returned as the value of the result field in the response to the HTTP POST request. The response to the HTTP POST request should be a JSON object in the format: { \"message\" : { \"text\" : \"Response to function call\" , } } Using the Fixie Python SDK, implementing an Agent function is done using the @fixieai.CodeShotAgent.register_func decorator. The decorator takes a single argument, which is the function to be registered. The function must take a single argument, which contains the JSON message object from the HTTP POST request. The function should return a string, which will be the value of the text field in the response message returned by the Agent. See python-agent-api.md for more information on the Fixie Python Agent API, and agent-quickstart.md for a quickstart guide on how to implement Agents in Fixie.","title":"Agent Protocol"},{"location":"agent-protocol/#fixie-agent-protocol","text":"Fixie Agents can be implemented in any programming language. The Fixie Python Agent API provides a Python SDK that makes it easy to implement Agents in Python, however, it is possible to implement Fixie Agents in any programming language, as long as the Agent code conforms to the following protocol. A Fixie Agent is a program that accepts HTTP requests of two types: An HTTP GET request to the / endpoint, which returns a list of few-shot examples that the Agent supports. An HTTP POST request to the /FUNC endpoint, which returns the result of calling the function FUNC with the parameters specified in the request. Agents can support multiple functions.","title":"Fixie Agent Protocol"},{"location":"agent-protocol/#few-shot-examples","text":"Upon receiving an HTTP GET request to the / endpoint, the Agent must return a list of few-shot examples that the Agent supports. The few-shot examples are used to provide examples to the underlying Large Language Model, such as GPT-3, as well as to provide the Fixie Platform information on what kinds of queries this Agent can support. The few-shot examples are returned as a JSON object with the following format: { \"base_prompt\" : \"The base prompt for the few-shot examples.\" , \"few_shots\" : [ \"The first few-shot example.\" , \"The second few-shot example.\" , \"The third few-shot example.\" ] } Each few-shot excample consists of one or more lines, separating by a newline character ( \\n ). The first line of each example must be a sample query, which must start with the prefix Q: . The final line of the few-shot example must be the corresponding answer, which must start with the prefix A: . The few-shot example may contain any number of lines in between the query and answer, representing intermediate outputs from the Large Language Model, as well as responses to the LLM from external functions. Here is an example of a single few-shot example: Q : Generate a random number between 0 and 19. Ask Func [ genrand ] : 0 , 19 Func [ genrand ] says : 17 A : The random number is 17. In this example, the first line represents a sample query that the Agent can support. The second line is the LLM response to receiving this query, which in this case indicates that the Function genrand should be invoked with the input string 0, 19 . The third line is the expected response from the Function genrand , and the final line is the answer to the query. Using the Fixie Python SDK, the values of the base_prompt and few_shots fields are specified by setting the values of the BASE_PROMPT and FEW_SHOTS variables in the Agent code, respectively.","title":"Few-shot examples"},{"location":"agent-protocol/#function-invocation","text":"Upon receiving an HTTP POST request to the /FUNC endpoint, the Agent must return the result of calling the Agent function FUNC with the parameters specified in the body of the HTTP POST request. The body of the POST request will be in the following format: { \"message\" : { \"text\" : \"Argument to function call\" , } } The Agent should invoke the function FUNC , passing in the contents of the JSON object message as the argument to the function call. The result of the function call should be returned as the value of the result field in the response to the HTTP POST request. The response to the HTTP POST request should be a JSON object in the format: { \"message\" : { \"text\" : \"Response to function call\" , } } Using the Fixie Python SDK, implementing an Agent function is done using the @fixieai.CodeShotAgent.register_func decorator. The decorator takes a single argument, which is the function to be registered. The function must take a single argument, which contains the JSON message object from the HTTP POST request. The function should return a string, which will be the value of the text field in the response message returned by the Agent. See python-agent-api.md for more information on the Fixie Python Agent API, and agent-quickstart.md for a quickstart guide on how to implement Agents in Fixie.","title":"Function invocation"},{"location":"agent-quickstart/","text":"Fixie Agent Quickstart Fixie allows you to extend the capabilities of the Fixie Platform by building your own Agents , which are specialized software components that combine a set of few-shot examples with code to invoke external systems. We call this combination of few-shots coupled with code Code Shots (clever, eh?). You can implement Fixie Agents in any programming language, however, the Fixie SDK currently provides bindings only for Python. See the Agent Protocol for details on implementing your own Agent in a language other than Python. We'll be shipping bindings for other languages soon! Create a Fixie Agent The first step is to create a new Agent directory using the fixie init command: $ mkdir myagent $ cd myagent $ fixie init Handle [ myagent ] : Description [] : A simple test agent. Entry point [ main:agent ] : More info url [] : Public [ False ] : fixie init will prompt you to enter some information about your Agent. The Agent Handle is its unique identifier, and is used to identify the Agent in the Fixie Platform. The Description is an optional plain-text description of the Agent's abilities. The Entry point is the name of the Python module that contains the Agent code, which we will create in the next step below. The More info url is an optional URL that you can provide that provides more information about the Agent; this can point to any website. The Public flag indicates whether the Agent should be publicly visible in the Fixie Platform for other users. If you set this to True , then anyone can use your Agent in their own applications. Running fixie init will create the file agent.yaml in the current directory, containing metadata on the Agent. Write the Agent code Next, paste the following code into a file called main.py : import random import fixieai BASE_PROMPT = \"I am a simple agent that generates a random number between two given values.\" FEW_SHOTS = \"\"\" Q: Generate a random number between 0 and 19. Ask Func[genrand]: 0, 19 Func[genrand] says: 17 A: The random number is 17. Q: Generate a random value from 5 to 10, inclusive. Ask Func[genrand]: 5, 10 Func[genrand] says: 8 A: The random number is 8. \"\"\" agent = fixieai . CodeShotAgent ( BASE_PROMPT , FEW_SHOTS ) @agent . register_func () def genrand ( query : fixieai . Message ) -> str : low , high = query . text . replace ( \" \" , \"\" ) . split ( \",\" ) return str ( random . randint ( int ( low ), int ( high ))) The code consists of two main parts: BASE_PROMPT and FEW_SHOTS : These are the few-shot examples that define the Agent's purpose and behavior. The few-shots are used to providing examples to the underlying Large Language Model, such as GPT-3, as well as to provide the Fixie Platform information on what kinds of queries this Agent can support. Code snippets : These are the functions that are invoked by the Code Shots. The code snippets are registered with the agent using the register_func decorator. In the FEW_SHOTS string, the Func[genrand] keyword indicates that the function genrand should be invoked when the output of the underlying LLM starts with this string. The values following Ask Func[genrand]: are passed to the function as the query.text parameter. In this case, the function parses out the values and returns a random number between those two values. Test your Agent To test your Agent, you have two options: (1) Run it on your local machine using the fixie agent serve command, or (2) Deploy it to the Fixie platform using the fixie agent deploy command. Using fixie agent serve allows you to debug the agent as it runs locally, but is generally only advisable for initial development. $ fixie serve Opening tunnel to 0 .0.0.0:8181... Tunneling 0 .0.0.0:8181 via https://df03e6d61a9f11.lhr.life When running fixie agent serve , a tunnel is set up that allows the Agent, running on your local machine, to be accessed from the Fixie Platform. The URL of the tunnel is printed on the console. If you quit the fixie agent serve process (e.g., by pressing Ctrl-C), the tunnel is torn down and your Agent is no longer accessible. Now you can use fixie console to send a message to your Agent directly: $ fixie console Welcome to Fixie! Connected to: https://app.fixie.ai/sessions/stormy-luxuriant-ferryboat fixie \ud83e\udd8a\u276f @myagent Generate a random number between 10 and 50 @user: @mdw/myagent Generate a random number between 10 and 50 @myagent: Generate a random number between 10 and 50 @myagent: Ask Func: 10 , 50 @myagent: Func says: 48 @myagent: The random number is 48 . 1 \u276f The random number is 48 . In the fixie agent serve window, you should also see debugging output showing that your Agent code was invoked with a POST request to the /genrand endpoint. Deploy your Agent Agents can be deployed on any web server that supports Python, however, you can also deploy your Agent directly to the Fixie platform, which takes care of hosting the Agent functions in the cloud. For this, all you need to do is run fixie agent deploy : $ fixie agent deploy \u2705 Deploying... \u2705 Refreshing... This will take about a minute to run. Once deployed, you can use your Agent via the Fixie web UI or the fixie console tool. Implementing Agents without Python See Agent Protocol for details on how to implement an Agent directly in a language other than Python, as well as Agent API for details on the complete Fixie Agent API.","title":"Agent QuickStart"},{"location":"agent-quickstart/#fixie-agent-quickstart","text":"Fixie allows you to extend the capabilities of the Fixie Platform by building your own Agents , which are specialized software components that combine a set of few-shot examples with code to invoke external systems. We call this combination of few-shots coupled with code Code Shots (clever, eh?). You can implement Fixie Agents in any programming language, however, the Fixie SDK currently provides bindings only for Python. See the Agent Protocol for details on implementing your own Agent in a language other than Python. We'll be shipping bindings for other languages soon!","title":"Fixie Agent Quickstart"},{"location":"agent-quickstart/#create-a-fixie-agent","text":"The first step is to create a new Agent directory using the fixie init command: $ mkdir myagent $ cd myagent $ fixie init Handle [ myagent ] : Description [] : A simple test agent. Entry point [ main:agent ] : More info url [] : Public [ False ] : fixie init will prompt you to enter some information about your Agent. The Agent Handle is its unique identifier, and is used to identify the Agent in the Fixie Platform. The Description is an optional plain-text description of the Agent's abilities. The Entry point is the name of the Python module that contains the Agent code, which we will create in the next step below. The More info url is an optional URL that you can provide that provides more information about the Agent; this can point to any website. The Public flag indicates whether the Agent should be publicly visible in the Fixie Platform for other users. If you set this to True , then anyone can use your Agent in their own applications. Running fixie init will create the file agent.yaml in the current directory, containing metadata on the Agent.","title":"Create a Fixie Agent"},{"location":"agent-quickstart/#write-the-agent-code","text":"Next, paste the following code into a file called main.py : import random import fixieai BASE_PROMPT = \"I am a simple agent that generates a random number between two given values.\" FEW_SHOTS = \"\"\" Q: Generate a random number between 0 and 19. Ask Func[genrand]: 0, 19 Func[genrand] says: 17 A: The random number is 17. Q: Generate a random value from 5 to 10, inclusive. Ask Func[genrand]: 5, 10 Func[genrand] says: 8 A: The random number is 8. \"\"\" agent = fixieai . CodeShotAgent ( BASE_PROMPT , FEW_SHOTS ) @agent . register_func () def genrand ( query : fixieai . Message ) -> str : low , high = query . text . replace ( \" \" , \"\" ) . split ( \",\" ) return str ( random . randint ( int ( low ), int ( high ))) The code consists of two main parts: BASE_PROMPT and FEW_SHOTS : These are the few-shot examples that define the Agent's purpose and behavior. The few-shots are used to providing examples to the underlying Large Language Model, such as GPT-3, as well as to provide the Fixie Platform information on what kinds of queries this Agent can support. Code snippets : These are the functions that are invoked by the Code Shots. The code snippets are registered with the agent using the register_func decorator. In the FEW_SHOTS string, the Func[genrand] keyword indicates that the function genrand should be invoked when the output of the underlying LLM starts with this string. The values following Ask Func[genrand]: are passed to the function as the query.text parameter. In this case, the function parses out the values and returns a random number between those two values.","title":"Write the Agent code"},{"location":"agent-quickstart/#test-your-agent","text":"To test your Agent, you have two options: (1) Run it on your local machine using the fixie agent serve command, or (2) Deploy it to the Fixie platform using the fixie agent deploy command. Using fixie agent serve allows you to debug the agent as it runs locally, but is generally only advisable for initial development. $ fixie serve Opening tunnel to 0 .0.0.0:8181... Tunneling 0 .0.0.0:8181 via https://df03e6d61a9f11.lhr.life When running fixie agent serve , a tunnel is set up that allows the Agent, running on your local machine, to be accessed from the Fixie Platform. The URL of the tunnel is printed on the console. If you quit the fixie agent serve process (e.g., by pressing Ctrl-C), the tunnel is torn down and your Agent is no longer accessible. Now you can use fixie console to send a message to your Agent directly: $ fixie console Welcome to Fixie! Connected to: https://app.fixie.ai/sessions/stormy-luxuriant-ferryboat fixie \ud83e\udd8a\u276f @myagent Generate a random number between 10 and 50 @user: @mdw/myagent Generate a random number between 10 and 50 @myagent: Generate a random number between 10 and 50 @myagent: Ask Func: 10 , 50 @myagent: Func says: 48 @myagent: The random number is 48 . 1 \u276f The random number is 48 . In the fixie agent serve window, you should also see debugging output showing that your Agent code was invoked with a POST request to the /genrand endpoint.","title":"Test your Agent"},{"location":"agent-quickstart/#deploy-your-agent","text":"Agents can be deployed on any web server that supports Python, however, you can also deploy your Agent directly to the Fixie platform, which takes care of hosting the Agent functions in the cloud. For this, all you need to do is run fixie agent deploy : $ fixie agent deploy \u2705 Deploying... \u2705 Refreshing... This will take about a minute to run. Once deployed, you can use your Agent via the Fixie web UI or the fixie console tool.","title":"Deploy your Agent"},{"location":"agent-quickstart/#implementing-agents-without-python","text":"See Agent Protocol for details on how to implement an Agent directly in a language other than Python, as well as Agent API for details on the complete Fixie Agent API.","title":"Implementing Agents without Python"},{"location":"agents/","text":"Developing a Fixie Agent The Fixie platform allows you to build Agents in any language of your choice, by writing a service that conforms to the protocol described in Agent Protocol . For Python developers, we provide a Python library that makes it easy to implement Agents using the API described below. For a quick start on building your own Fixie Agent, check out the Quick Start guide. See Fixie Agent Python API for the full API reference. CodeShotAgent The base class for Agents in Fixie is [ CodeShotAgent ][fixieai.agents.code_shot. codeshotagent]. This class takes care of communicating with the Fixie platform via the Agent Protocol , and provides a simple API for registering functions that can be invoked by the few-shot examples used by the Agent. The structure of a CodeShotAgent is typically as follows: import fixieai BASE_PROMPT = \"Base prompt for the agent.\" FEW_SHOTS = \"\"\" Q: Example query for the Agent Ask Func[my_func]: query to the func Func[my_func] says: response to the query A: Response generated by the Agent Q: Second example query to the agent A: Second response generated by the Agent \"\"\" agent = fixieai . CodeShotAgent ( BASE_PROMPT , FEW_SHOTS ) @agent . register_func () def my_func ( query : fixieai . Message ) -> str : return \"Response to the query\" The BASE_PROMPT and FEW_SHOTS strings are used to provide examples to the underlying Large Language Model, such as GPT-3, as well as to provide the Fixie Platform information on what kinds of queries this Agent can support. The FEW_SHOTS provided to an Agent must be a string consisting of one or more stanzas , where each stanza consists of a question, one or more rounds of internal actions taken by the Agent, and a final answer. Stanzas must be separated from each other by a blank line. The query line in the stanza must start with Q: , and the answer line must start with A: . Internal actions taken by the Agent can be of one of two forms: Ask Func[<func_name>]: <query_text> : This indicates that the function <func_name> should be invoked when the output of the underlying LLM starts with this string. The string following Ask Func[<func_name>]: is passed to the function as the query.text parameter. Ask Agent[<agent_name>]: <query_text> : This indicates that the Agent <agent_name> should be invoked when the output of the underlying LLM starts with this string. The string following Ask Agent[<agent_name>]: is passed to the Agent as the query.text parameter. Agent Funcs A Func is a function, defined in Python, that can be invoked by the Agent. (Note that Funcs need not be implemented in Python; you can implement Agents in other languages, as long as they adhere to the Fixie Agent Protocol .) As described above, when the language model for an Agent emits the token Ask Func[<func_name>] , the function <func_name> will be invoked. The register_func decorator is used to register a function that can be invoked by the Agent. A function registered with the register_func decorator has the signature: @agent . register_func () def my_func ( query , user_storage = None , oauth_handler = None ): ... The query parameter is either a str a Message object. If the query parameter is a string, this parameter contains the text of the Agent query. If the query parameter is a Message object, this parameter contains the text of the Agent along with zero or more Embed objects, as described in the Embeds section below. The optional user_storage parameter provides the Func an interface to the Fixie User Storage service, as described below. The optional oauth_handler parameter provides the Func an interface to performing OAuth authentication with external services, as described in the OAuth section below. The function must return either a str or a Message object. Returning a string is equivalent to returning a Message object with the string as its text field, and no embeds . Embeds Embeds allow arbitrary binary data to be associated with a query or response Message in Fixie, similar to email attachments. Embeds can be used to store images, video, text, or any other binary data. Embeds are represented by the Embed class. Agents can access the Embeds associated with a Message as follows: @agent . register_func () def my_func ( query : fixieai . Message ) -> str : for key , embed in query . embeds . items (): print ( f \"Embed key: { key } \" ) print ( f \"Embed content-type: { embed . content_type } \" ) embed_value_as_text = embed . text embed_value_as_bytes = embed . content An Agent function can also add an Embed to its response Message by adding it to the embeds dictionary of the Message object: @agent . register_func () def my_func ( query : fixieai . Message ) -> fixieai . Message : reply = fixieai . Message ( \"Response to the query\" ) reply . embeds [ \"my_embed\" ] = fixieai . Embed ( content_type = \"text/plain\" ) reply . embeds [ \"my_embed\" ] . text = \"Hello, world!\" Embeds can be queried by leveraging the built-in fixie_query_embed func. e.g., Ask Func[fixie_query_embed] . See example of how this works. External Knowledge Base Support Fixie Agents come with built-in support for indexing and querying external knowledge in the form of URLs. See the support agent for an example of how to use this. URLS = [ \"https://docs.fixie.ai/*\" , ] DOCS = [ fixieai . DocumentCorpus ( urls = URLS )] agent = fixieai . CodeShotAgent ( BASE_PROMPT , FEW_SHOTS , DOCS ) Appending * to the end of the URL will tell Fixie to automatically index all children of the root URL. After indexing, you can query the corpus using the build in Ask Func[fixie_query_corpus] function. Note: It can take up to 10 minutes to index content, depending on the number of URLs and content size. We're working on a mechanism to alert you to indexing progress. Stay tuned! User Storage Fixie Agents can store and retrieve arbitrary data associated with a user, using the UserStorage class. This class provides a simple interface to a persistent key/value storage service, with a separate key/value store for each Fixie user. This can be used to maintain state about a particular user that persists across Agent invocations. The UserStorage instance for a given query can be obtained by providing a user_storage parameter to an Agent function. The UserStorage object acts as a Python dict that stores state associated with an arbitrary string key. UserStorage values may consist of Python primitive types, such as str , int , float , bool , None , or bytes , as well as lists of these types, or a Dict mapping a str to one of these types. User Storage Example @agent . register_func () def my_func ( query : fixieai . Message , user_storage : fixieai . UserStorage ) -> str : user_storage [ \"my_key\" ] = \"my_value\" return user_storage [ \"my_key\" ] Agent OAuth Support Fixie Agents can authenticate to third-party services to perform actions on behalf of the user. This is done using OAuth 2.0, which is a standard protocol for authorization. OAuth 2.0 allows users to grant limited access to their accounts on one service, to another service, without having to share their password. Fixie provides a simple interface for Agents to perform OAuth authentication, using the OAuthParams class. Using this class, an Agent function can use the OAuthHandler class -- which is passed to the function as the oauth_handler parameter -- to obtain an access token for the user. OAuth Example import fixieai oauth_params = fixieai . OAuthParams () oauth_params . client_id = \"XXXXX.apps.googleusercontent.com\" , oauth_params . auth_uri = \"https://accounts.google.com/o/oauth2/auth\" oauth_params . token_uri = \"https://oauth2.googleapis.com/token\" oauth_params . client_secret = \"XXXXXXXXX\" agent = fixieai . CodeShotAgent ( BASE_PROMPT , FEW_SHOTS , oauth_params = oauth_params ) @agent . register_func def my_func ( query , oauth_handler : fixieai . OAuthHandler ): user_token = oauth_handler . user_token () if user_token is None : # Return the URL that the user should click on to authorize the Agent. return oauth_handler . get_authorization_url () # Do something with the user_token returned by the OAuth handler. client = gcalendar_client . GcalendarClient ( user_token ) # ... Agent Default Model and Model Params By default, agents use the text-davinci-003 model from OpenAI with a default temperature of 0 and a maximum_tokens size of 1,000. We've found this to be the right default for many use cases, but it's easy to change by passing in llm_settings when initializing your CodeShotAgent . Here's an example: agent = fixieai . CodeShotAgent ( BASE_PROMPT , [], conversational = True , llm_settings = fixieai . LlmSettings ( temperature = 1.0 , model = \"openai/gpt-4\" , maximum_tokens = 500 ), ) Here are the following models that we support: Model Name Identifier String GPT-3 openai/text-davinci-003 (default) GPT-3.5 (ChatGPT) openai/gpt-3.5-turbo GPT-4 openai/gpt-4 AI21 J2 Grande ai21/j2-grande AI21 J2 Jumbo ai21/j2-jumbo GooseAI GPTJ 6B gooseai/gpt-j-6b GooseAI GPT NEO 20B gooseai/gpt-neo-20b Built-in functions All Fixie agents have access to the following set of built-in functions that they can invoke. Ask Func[fixie_base_prompt] : Returns the base prompt for the agent. Ask Func[fixie_local_datetime] : Returns the current datetime in the user's local timezone. Ask Func[fixie_utc_datetime] : Returns the current datetime in UTC timezone. Ask Func[fixie_query_embed] : Runs the prompt in the query against the contents of the embed. Ask Func[fixie_query_corpus] : Runs the prompt in the query against the contents of the agent-defined corpus.","title":"Fixie Agent API"},{"location":"agents/#developing-a-fixie-agent","text":"The Fixie platform allows you to build Agents in any language of your choice, by writing a service that conforms to the protocol described in Agent Protocol . For Python developers, we provide a Python library that makes it easy to implement Agents using the API described below. For a quick start on building your own Fixie Agent, check out the Quick Start guide. See Fixie Agent Python API for the full API reference.","title":"Developing a Fixie Agent"},{"location":"agents/#codeshotagent","text":"The base class for Agents in Fixie is [ CodeShotAgent ][fixieai.agents.code_shot. codeshotagent]. This class takes care of communicating with the Fixie platform via the Agent Protocol , and provides a simple API for registering functions that can be invoked by the few-shot examples used by the Agent. The structure of a CodeShotAgent is typically as follows: import fixieai BASE_PROMPT = \"Base prompt for the agent.\" FEW_SHOTS = \"\"\" Q: Example query for the Agent Ask Func[my_func]: query to the func Func[my_func] says: response to the query A: Response generated by the Agent Q: Second example query to the agent A: Second response generated by the Agent \"\"\" agent = fixieai . CodeShotAgent ( BASE_PROMPT , FEW_SHOTS ) @agent . register_func () def my_func ( query : fixieai . Message ) -> str : return \"Response to the query\" The BASE_PROMPT and FEW_SHOTS strings are used to provide examples to the underlying Large Language Model, such as GPT-3, as well as to provide the Fixie Platform information on what kinds of queries this Agent can support. The FEW_SHOTS provided to an Agent must be a string consisting of one or more stanzas , where each stanza consists of a question, one or more rounds of internal actions taken by the Agent, and a final answer. Stanzas must be separated from each other by a blank line. The query line in the stanza must start with Q: , and the answer line must start with A: . Internal actions taken by the Agent can be of one of two forms: Ask Func[<func_name>]: <query_text> : This indicates that the function <func_name> should be invoked when the output of the underlying LLM starts with this string. The string following Ask Func[<func_name>]: is passed to the function as the query.text parameter. Ask Agent[<agent_name>]: <query_text> : This indicates that the Agent <agent_name> should be invoked when the output of the underlying LLM starts with this string. The string following Ask Agent[<agent_name>]: is passed to the Agent as the query.text parameter.","title":"CodeShotAgent"},{"location":"agents/#agent-funcs","text":"A Func is a function, defined in Python, that can be invoked by the Agent. (Note that Funcs need not be implemented in Python; you can implement Agents in other languages, as long as they adhere to the Fixie Agent Protocol .) As described above, when the language model for an Agent emits the token Ask Func[<func_name>] , the function <func_name> will be invoked. The register_func decorator is used to register a function that can be invoked by the Agent. A function registered with the register_func decorator has the signature: @agent . register_func () def my_func ( query , user_storage = None , oauth_handler = None ): ... The query parameter is either a str a Message object. If the query parameter is a string, this parameter contains the text of the Agent query. If the query parameter is a Message object, this parameter contains the text of the Agent along with zero or more Embed objects, as described in the Embeds section below. The optional user_storage parameter provides the Func an interface to the Fixie User Storage service, as described below. The optional oauth_handler parameter provides the Func an interface to performing OAuth authentication with external services, as described in the OAuth section below. The function must return either a str or a Message object. Returning a string is equivalent to returning a Message object with the string as its text field, and no embeds .","title":"Agent Funcs"},{"location":"agents/#embeds","text":"Embeds allow arbitrary binary data to be associated with a query or response Message in Fixie, similar to email attachments. Embeds can be used to store images, video, text, or any other binary data. Embeds are represented by the Embed class. Agents can access the Embeds associated with a Message as follows: @agent . register_func () def my_func ( query : fixieai . Message ) -> str : for key , embed in query . embeds . items (): print ( f \"Embed key: { key } \" ) print ( f \"Embed content-type: { embed . content_type } \" ) embed_value_as_text = embed . text embed_value_as_bytes = embed . content An Agent function can also add an Embed to its response Message by adding it to the embeds dictionary of the Message object: @agent . register_func () def my_func ( query : fixieai . Message ) -> fixieai . Message : reply = fixieai . Message ( \"Response to the query\" ) reply . embeds [ \"my_embed\" ] = fixieai . Embed ( content_type = \"text/plain\" ) reply . embeds [ \"my_embed\" ] . text = \"Hello, world!\" Embeds can be queried by leveraging the built-in fixie_query_embed func. e.g., Ask Func[fixie_query_embed] . See example of how this works.","title":"Embeds"},{"location":"agents/#external-knowledge-base-support","text":"Fixie Agents come with built-in support for indexing and querying external knowledge in the form of URLs. See the support agent for an example of how to use this. URLS = [ \"https://docs.fixie.ai/*\" , ] DOCS = [ fixieai . DocumentCorpus ( urls = URLS )] agent = fixieai . CodeShotAgent ( BASE_PROMPT , FEW_SHOTS , DOCS ) Appending * to the end of the URL will tell Fixie to automatically index all children of the root URL. After indexing, you can query the corpus using the build in Ask Func[fixie_query_corpus] function. Note: It can take up to 10 minutes to index content, depending on the number of URLs and content size. We're working on a mechanism to alert you to indexing progress. Stay tuned!","title":"External Knowledge Base Support"},{"location":"agents/#user-storage","text":"Fixie Agents can store and retrieve arbitrary data associated with a user, using the UserStorage class. This class provides a simple interface to a persistent key/value storage service, with a separate key/value store for each Fixie user. This can be used to maintain state about a particular user that persists across Agent invocations. The UserStorage instance for a given query can be obtained by providing a user_storage parameter to an Agent function. The UserStorage object acts as a Python dict that stores state associated with an arbitrary string key. UserStorage values may consist of Python primitive types, such as str , int , float , bool , None , or bytes , as well as lists of these types, or a Dict mapping a str to one of these types.","title":"User Storage"},{"location":"agents/#user-storage-example","text":"@agent . register_func () def my_func ( query : fixieai . Message , user_storage : fixieai . UserStorage ) -> str : user_storage [ \"my_key\" ] = \"my_value\" return user_storage [ \"my_key\" ]","title":"User Storage Example"},{"location":"agents/#agent-oauth-support","text":"Fixie Agents can authenticate to third-party services to perform actions on behalf of the user. This is done using OAuth 2.0, which is a standard protocol for authorization. OAuth 2.0 allows users to grant limited access to their accounts on one service, to another service, without having to share their password. Fixie provides a simple interface for Agents to perform OAuth authentication, using the OAuthParams class. Using this class, an Agent function can use the OAuthHandler class -- which is passed to the function as the oauth_handler parameter -- to obtain an access token for the user.","title":"Agent OAuth Support"},{"location":"agents/#oauth-example","text":"import fixieai oauth_params = fixieai . OAuthParams () oauth_params . client_id = \"XXXXX.apps.googleusercontent.com\" , oauth_params . auth_uri = \"https://accounts.google.com/o/oauth2/auth\" oauth_params . token_uri = \"https://oauth2.googleapis.com/token\" oauth_params . client_secret = \"XXXXXXXXX\" agent = fixieai . CodeShotAgent ( BASE_PROMPT , FEW_SHOTS , oauth_params = oauth_params ) @agent . register_func def my_func ( query , oauth_handler : fixieai . OAuthHandler ): user_token = oauth_handler . user_token () if user_token is None : # Return the URL that the user should click on to authorize the Agent. return oauth_handler . get_authorization_url () # Do something with the user_token returned by the OAuth handler. client = gcalendar_client . GcalendarClient ( user_token ) # ...","title":"OAuth Example"},{"location":"agents/#agent-default-model-and-model-params","text":"By default, agents use the text-davinci-003 model from OpenAI with a default temperature of 0 and a maximum_tokens size of 1,000. We've found this to be the right default for many use cases, but it's easy to change by passing in llm_settings when initializing your CodeShotAgent . Here's an example: agent = fixieai . CodeShotAgent ( BASE_PROMPT , [], conversational = True , llm_settings = fixieai . LlmSettings ( temperature = 1.0 , model = \"openai/gpt-4\" , maximum_tokens = 500 ), ) Here are the following models that we support: Model Name Identifier String GPT-3 openai/text-davinci-003 (default) GPT-3.5 (ChatGPT) openai/gpt-3.5-turbo GPT-4 openai/gpt-4 AI21 J2 Grande ai21/j2-grande AI21 J2 Jumbo ai21/j2-jumbo GooseAI GPTJ 6B gooseai/gpt-j-6b GooseAI GPT NEO 20B gooseai/gpt-neo-20b","title":"Agent Default Model and Model Params"},{"location":"agents/#built-in-functions","text":"All Fixie agents have access to the following set of built-in functions that they can invoke. Ask Func[fixie_base_prompt] : Returns the base prompt for the agent. Ask Func[fixie_local_datetime] : Returns the current datetime in the user's local timezone. Ask Func[fixie_utc_datetime] : Returns the current datetime in UTC timezone. Ask Func[fixie_query_embed] : Runs the prompt in the query against the contents of the embed. Ask Func[fixie_query_corpus] : Runs the prompt in the query against the contents of the agent-defined corpus.","title":"Built-in functions"},{"location":"architecture/","text":"Fixie Architecture Overview This page provides a technical overview of the Fixie platform, specifically focusing on the programming model used to build applications with Fixie. System overview The diagram below is a high level sketch of the Fixie platform. The Fixie system consists of a cloud-hosted API (app.fixie.ai) which provides a GraphQL-based API endpoint to clients, and a set of Agents that each have a specific set of skills, such as accessing a remote API, pulling data from a database, summarizing text, and so forth. The core Fixie service runs on the cloud or on-prem in a customers environment. Agents can run anywhere: Hosted by Fixie, hosted by a customer, or hosted by third parties. Each Agent is its own independent microservice. Fixie's Agent registry maintains metadata about each agent, including its description, owner information, and the URL on which messages can be sent to the Agent. GraphQL API The Fixie GraphQL API allows clients to interact with the system in a number of ways: Query the set of Agents in the system, returning metadata about each Agent such as the name, owner, set of example queries that the Agent supports, etc. Register a new agent (described in the Creating an Agent section below). Create, list, and delete Sessions. A Session can be thought of as a chat session with the Fixie system, between the client and one or more Agents. Post a Message to a Session, which sends a new query to Fixie for processing by the system. Retrieve the Messages in a Session, including those Messages sent by Agents. Example query flow To illustrate the system working end-to-end, lets walk through what happens when a client issues a query, such as \"Schedule a 30-minute meeting with Zach sometime between now and next Tuesday\" . The red circled numbers on the diagram above refer to each of the steps below. The client issues the query by posting a message to a Session, via the GraphQL API (or, equivalently, via the web playground). The Session Runner dispatches the users query to the Fixie Agent. The Fixie Agent is the first Agent in the query sequence, and is responsible for taking the users query, breaking it into steps, and dispatching it out to one or more Agents for processing of those steps. Think of the Fixie Agent as a virtual machine that runs the program specified by the users query. The Session Runner is responsible for maintaining the running chat log of the session, and providing this context to the Fixie Agent. For example, if the following query were something vague, like \"When is it?\" , the Fixie Agent could disambiguate this to mean \"When is the meeting that you just scheduled?\" based on the session history provided by the Session Runner. For each step in the program, the Fixie Agent calls out to the Router Agent to determine which Agent(s) need to be invoked to run that step of the query. The Router Agent consults the Agent Registry, which contains metadata about each Agent, including the Agents name, owner, and (critically) the sample queries that the Agent can support. For example, the GitHub agent can support a wide range of queries about GitHub-related things, such as \"How many pull requests are open in fixie-ai/fixie?\" . When an Agent is registered with the system, it stores its sample queries in the registry, which the Router Agent uses to determine which queries should be routed to that Agent. The Router determines which Agent to send the query to by using a neural search that maps the users query into a high-dimensional embedding space, and compares it to the sample queries for each of the Agents in the system. The Router sends the users query to the Agent that most closely matches the sample queries for that Agent. The Agent (in this case, perhaps the Google Calendar Agent) gets the query and executes it. This is typically done by using a large language model such as GPT-3 to interpret the query and invoke one or more external systems to generate a response. In the case of the example query given above, this would entail querying the users own calendar for available time slots, querying Zachs calendar for available time slots, finding a suitable time that works for both parties, and then scheduling the meeting. Well describe this process in more detail in the Agent Execution section below. Finally, the response from the Agent is returned up the chain back to the Fixie Agent, which may decide to compose and send a final response to the user, or invoke other steps of the program involving other Agents. The response message is stored in the Session associated with this query, as well as returned to the client application. (The response path is not shown on the diagram for sake of simplicity.) Query message format Queries in Fixie consist of two parts: A plain-text Message along with zero or more Embeds. Concretely, a query message in Fixie is a JSON object that might contain: { \"text\" : \"Mask out the background in #1\" , \"embeds\" : { \"1\" : { \"content_type\" : \"image/png\" , \"uri\" : \"https://app.fixie.ai/attachment/21cfa1...\" , } } An Embed is very much like an email attachment: it is a binary object with an associated MIME type, such as image/png or text/plain , that is carried along with the query. Agents can access the Embeds associated with the query, and optionally create new Embeds that represent the result of some data processing or generation. As an example, the DALL-E and Stable Diffusion Agents both create Embeds for the images they generate. The Masker agent takes an image Embed and generates a binary mask representing portions of the image that contain a given object or material (e.g.,whatever is in the background of the image). Embeds are immutable once created. They are stored in a Fixie-managed cloud storage bucket, and are passed by reference (specifically, using a signed URL) along with the query. The text of the query can refer to an Embed using its key in the message. In the above example, the Embed key is 1 , and the query refers to it using #1 . Creating an Agent A Fixie Agent is just a program that accepts a query (text with optional embeds) in the format shown above, and returns a reply in the same format. An Agent can run anywhere on the Internet; Fixie only needs to know the URL to post the query message to over HTTP. The simplest possible Agent, implemented in Python, might look like this: from flask import Flask , request app = Flask ( __name__ ) @app . route ( \"/\" , methods = [ \"POST\" ]) def agent (): query = request . json [ \"text\" ] embeds = request . json [ \"embeds\" ] # Do something with the query... return { \"text\" : \"Hello, world!\" } That\u2019s it! Sending a POST request to the Agent\u2019s URL will return a reply \"Hello, world!\" . Of course, most Fixie Agents will want to use a large language model to process incoming queries and generate responses. There are two ways of doing this in Fixie. Fully custom Agents An Agent can essentially do anything it likes with the input query. The most common pattern here is to directly call a Large Language Model. on its own, e.g., via the OpenAI GPT-3 API. Fixie is agnostic as to how the Agent performs its query processing; it could use GPT-3, a fine-tuned variant like InstructGPT, or a fully custom model provided by the Agent developer or a third party. Libraries like LangChain are sometimes helpful in interfacing the LLM to external code. Instead of using an LLM directly, an Agent can also just be a simple wrapper around a third party AI-powered service that can perform tasks such as text summarization, text generation, search, etc. Building an Agent that wraps, for example, Jasper.ai , Instructive.ai, or Copy.ai is quite easy to do. The benefit of this approach is that those siloed products suddenly become interconnected and composable with the rest of the capabilities in the Fixie ecosystem. Code Shot Agents In addition to the roll your own approach with custom Agents, Fixie provides a novel programming model for building Agents that we call Code Shots . In Large Language Models, the term few shots refers to a set of examples that can be provided to the model that instructs it to perform a specific task. Code Shots are essentially few shots enhanced with embedded code. This is probably best understood through an example. The following Code Shots manifest creates an Agent that understands how to translate English queries into stock price lookups: import fixieai import requests BASE_PROMPT = \"I am an Agent that answers questions about stock prices.\" FEW_SHOTS = \"\"\"Q: What is the current price for SYMBOL? Ask Func[quote]: SYMBOL Func[quote] says: $123.45 A: The current price for SYMBOL is $123.45. Q: SYMBOL share price Ask Func[quote]: SYMBOL Func[quote] says: $34.52 A: The share price for SYMBOL is $34.52. Q: Price for SYMBOL Ask Func[quote]: SYMBOL Func[quote] says: $99.11 A: The share price for SYMBOL is $99.11 \"\"\" agent = fixieai . CodeShotAgent ( BASE_PROMPT , FEW_SHOTS ) API_KEY = \"...\" @agent . register_func () def quote ( query ): symbol = query . message . text url = f \"https://www.alphavantage.co/query?function=GLOBAL_QUOTE&apikey= { API_KEY } &symbol= { symbol } \" response = requests . get ( url ) raw_price = response . json ()[ \"Global Quote\" ][ \"05. price\" ] dot = raw_price . index ( \".\" ) return raw_price [: dot + 3 ] agent . serve ( \"stockquote\" ) This is the entire code for the stock quote Agent. The code manifest consists of a set of few-shot examples (example queries and responses), coupled with a little bit of Python code that knows how to invoke an external API to fetch a stock quote. With Code Shots, the Agents functionality is partitioned across two domains: the language processing (done centrally, by Fixie), and the low-level Func invocations (done within the Agent's own sandbox, either in the customers infrastructure or within an environment that is hosted by us). Because a Func does not need to perform any language processing, it is just a simple function! Let\u2019s walk through what happens when a query comes into a Code Shot Agent. The Agent gets a query like \"What is the stock price for GOOG?\" Fixie takes the users query, along with the few-shot examples in the Code Shots manifest, and passes them to a LLM for processing. Note that this language processing is being done centrally, by Fixie, meaning we can automatically select the best LLM and prompt to handle the query, as well as augment the prompt with relevant context and session history. 3. In this case, the output of the LLM will be something like Ask Func[quote]: GOOG . This is basically saying that Fixie needs to invoke this low-level Func to perform the next step of processing. Fixie invokes the Func by sending a REST call over HTTP to the Agents URL, and getting back the response. Fixie then feeds the Funcs response back into the LLM, again with the appropriate prompt and context, to continue processing the query. In this case, the LLM will generate a response like \"A: The share price for GOOG is $105.22\" . 5. The final reply is sent back to the client, or the Agent that issued the original query. There are a few key things to note about Code Shots. First, they make it really easy to build new Agents, since the only thing the developer needs to do is write a few English-language examples of what the Agent does, along with, possibly, one or more simple Funcs that hook into the query processing logic. Second, Funcs need not be private to individual Agents: We are building an entire library of Funcs that Agents can use, including Funcs that evaluate simple computational expressions, fetch data over HTTP, and so forth. Many Agents can be built without implementing any new Funcs, just by calling existing ones. Registering an Agent Fixie users can create and register their own Agents in the system either via the GraphQL API or through the web interface. The only thing needed to create an Agent is to give it a name, a short description of what it does, and a URL to which Agent queries should be sent. Authentication Fixie ensures that all requests flowing through the system are associated with an end user. A user can get a Fixie account by visiting the web UI (https://app.fixie.ai) and signing up using email, a Google account, or a GitHub account. To access the Fixie GraphQL API, the user can get an API key from their profile page on the site. The API key must be provided in an Authorization: Bearer header when making API calls. The API key itself is a JWT, signed by the Fixie service, that identifies the user associated with the query. When Fixie sends a request to an Agent, the request carries with it a JWT (again, signed by Fixie) that identifies the user and the chat session ID. The Agent can verify that an incoming query is in fact coming from Fixie by checking the signature of this JWT. When the Agent wishes to send a query to another Agent, or invoke one of the API endpoints provided by Fixie, it must provide this JWT to prove that the request is being made in the context of an actual user query. Usage limits Fixie imposes generous usage limits on individual users and Agents to prevent abuse. We currently have a per-user daily limit of 1000 queries. If this turns out not to be adequate we can raise the limit or allow users to purchase additional credits. Agents invoking Fixie APIs, such as the User Storage mechanism described below, also have a rate limit on those calls. Code Shot Agents that use Fixies language processing capabilities will additionally have a limit on the number of tokens they can pass through the Fixie-provided LLM API in a given time period. User Storage Agents often need to maintain state associated with a given user or chat session in which they are involved. While Agents could simply implement their own mechanism for this (e.g., writing data to a database or a cloud storage bucket), we provide a simple API in Fixie for this purpose. Fixies User Storage component is a simple key-value store, allowing Agents to store and retrieve binary blobs associated with an Agent-provided key. This is akin to cookies in a browser context, allowing Agents to stash away information that they might need to access later.","title":"Architecture"},{"location":"architecture/#fixie-architecture-overview","text":"This page provides a technical overview of the Fixie platform, specifically focusing on the programming model used to build applications with Fixie.","title":"Fixie Architecture Overview"},{"location":"architecture/#system-overview","text":"The diagram below is a high level sketch of the Fixie platform. The Fixie system consists of a cloud-hosted API (app.fixie.ai) which provides a GraphQL-based API endpoint to clients, and a set of Agents that each have a specific set of skills, such as accessing a remote API, pulling data from a database, summarizing text, and so forth. The core Fixie service runs on the cloud or on-prem in a customers environment. Agents can run anywhere: Hosted by Fixie, hosted by a customer, or hosted by third parties. Each Agent is its own independent microservice. Fixie's Agent registry maintains metadata about each agent, including its description, owner information, and the URL on which messages can be sent to the Agent.","title":"System overview"},{"location":"architecture/#graphql-api","text":"The Fixie GraphQL API allows clients to interact with the system in a number of ways: Query the set of Agents in the system, returning metadata about each Agent such as the name, owner, set of example queries that the Agent supports, etc. Register a new agent (described in the Creating an Agent section below). Create, list, and delete Sessions. A Session can be thought of as a chat session with the Fixie system, between the client and one or more Agents. Post a Message to a Session, which sends a new query to Fixie for processing by the system. Retrieve the Messages in a Session, including those Messages sent by Agents.","title":"GraphQL API"},{"location":"architecture/#example-query-flow","text":"To illustrate the system working end-to-end, lets walk through what happens when a client issues a query, such as \"Schedule a 30-minute meeting with Zach sometime between now and next Tuesday\" . The red circled numbers on the diagram above refer to each of the steps below. The client issues the query by posting a message to a Session, via the GraphQL API (or, equivalently, via the web playground). The Session Runner dispatches the users query to the Fixie Agent. The Fixie Agent is the first Agent in the query sequence, and is responsible for taking the users query, breaking it into steps, and dispatching it out to one or more Agents for processing of those steps. Think of the Fixie Agent as a virtual machine that runs the program specified by the users query. The Session Runner is responsible for maintaining the running chat log of the session, and providing this context to the Fixie Agent. For example, if the following query were something vague, like \"When is it?\" , the Fixie Agent could disambiguate this to mean \"When is the meeting that you just scheduled?\" based on the session history provided by the Session Runner. For each step in the program, the Fixie Agent calls out to the Router Agent to determine which Agent(s) need to be invoked to run that step of the query. The Router Agent consults the Agent Registry, which contains metadata about each Agent, including the Agents name, owner, and (critically) the sample queries that the Agent can support. For example, the GitHub agent can support a wide range of queries about GitHub-related things, such as \"How many pull requests are open in fixie-ai/fixie?\" . When an Agent is registered with the system, it stores its sample queries in the registry, which the Router Agent uses to determine which queries should be routed to that Agent. The Router determines which Agent to send the query to by using a neural search that maps the users query into a high-dimensional embedding space, and compares it to the sample queries for each of the Agents in the system. The Router sends the users query to the Agent that most closely matches the sample queries for that Agent. The Agent (in this case, perhaps the Google Calendar Agent) gets the query and executes it. This is typically done by using a large language model such as GPT-3 to interpret the query and invoke one or more external systems to generate a response. In the case of the example query given above, this would entail querying the users own calendar for available time slots, querying Zachs calendar for available time slots, finding a suitable time that works for both parties, and then scheduling the meeting. Well describe this process in more detail in the Agent Execution section below. Finally, the response from the Agent is returned up the chain back to the Fixie Agent, which may decide to compose and send a final response to the user, or invoke other steps of the program involving other Agents. The response message is stored in the Session associated with this query, as well as returned to the client application. (The response path is not shown on the diagram for sake of simplicity.)","title":"Example query flow"},{"location":"architecture/#query-message-format","text":"Queries in Fixie consist of two parts: A plain-text Message along with zero or more Embeds. Concretely, a query message in Fixie is a JSON object that might contain: { \"text\" : \"Mask out the background in #1\" , \"embeds\" : { \"1\" : { \"content_type\" : \"image/png\" , \"uri\" : \"https://app.fixie.ai/attachment/21cfa1...\" , } } An Embed is very much like an email attachment: it is a binary object with an associated MIME type, such as image/png or text/plain , that is carried along with the query. Agents can access the Embeds associated with the query, and optionally create new Embeds that represent the result of some data processing or generation. As an example, the DALL-E and Stable Diffusion Agents both create Embeds for the images they generate. The Masker agent takes an image Embed and generates a binary mask representing portions of the image that contain a given object or material (e.g.,whatever is in the background of the image). Embeds are immutable once created. They are stored in a Fixie-managed cloud storage bucket, and are passed by reference (specifically, using a signed URL) along with the query. The text of the query can refer to an Embed using its key in the message. In the above example, the Embed key is 1 , and the query refers to it using #1 .","title":"Query message format"},{"location":"architecture/#creating-an-agent","text":"A Fixie Agent is just a program that accepts a query (text with optional embeds) in the format shown above, and returns a reply in the same format. An Agent can run anywhere on the Internet; Fixie only needs to know the URL to post the query message to over HTTP. The simplest possible Agent, implemented in Python, might look like this: from flask import Flask , request app = Flask ( __name__ ) @app . route ( \"/\" , methods = [ \"POST\" ]) def agent (): query = request . json [ \"text\" ] embeds = request . json [ \"embeds\" ] # Do something with the query... return { \"text\" : \"Hello, world!\" } That\u2019s it! Sending a POST request to the Agent\u2019s URL will return a reply \"Hello, world!\" . Of course, most Fixie Agents will want to use a large language model to process incoming queries and generate responses. There are two ways of doing this in Fixie.","title":"Creating an Agent"},{"location":"architecture/#fully-custom-agents","text":"An Agent can essentially do anything it likes with the input query. The most common pattern here is to directly call a Large Language Model. on its own, e.g., via the OpenAI GPT-3 API. Fixie is agnostic as to how the Agent performs its query processing; it could use GPT-3, a fine-tuned variant like InstructGPT, or a fully custom model provided by the Agent developer or a third party. Libraries like LangChain are sometimes helpful in interfacing the LLM to external code. Instead of using an LLM directly, an Agent can also just be a simple wrapper around a third party AI-powered service that can perform tasks such as text summarization, text generation, search, etc. Building an Agent that wraps, for example, Jasper.ai , Instructive.ai, or Copy.ai is quite easy to do. The benefit of this approach is that those siloed products suddenly become interconnected and composable with the rest of the capabilities in the Fixie ecosystem.","title":"Fully custom Agents"},{"location":"architecture/#code-shot-agents","text":"In addition to the roll your own approach with custom Agents, Fixie provides a novel programming model for building Agents that we call Code Shots . In Large Language Models, the term few shots refers to a set of examples that can be provided to the model that instructs it to perform a specific task. Code Shots are essentially few shots enhanced with embedded code. This is probably best understood through an example. The following Code Shots manifest creates an Agent that understands how to translate English queries into stock price lookups: import fixieai import requests BASE_PROMPT = \"I am an Agent that answers questions about stock prices.\" FEW_SHOTS = \"\"\"Q: What is the current price for SYMBOL? Ask Func[quote]: SYMBOL Func[quote] says: $123.45 A: The current price for SYMBOL is $123.45. Q: SYMBOL share price Ask Func[quote]: SYMBOL Func[quote] says: $34.52 A: The share price for SYMBOL is $34.52. Q: Price for SYMBOL Ask Func[quote]: SYMBOL Func[quote] says: $99.11 A: The share price for SYMBOL is $99.11 \"\"\" agent = fixieai . CodeShotAgent ( BASE_PROMPT , FEW_SHOTS ) API_KEY = \"...\" @agent . register_func () def quote ( query ): symbol = query . message . text url = f \"https://www.alphavantage.co/query?function=GLOBAL_QUOTE&apikey= { API_KEY } &symbol= { symbol } \" response = requests . get ( url ) raw_price = response . json ()[ \"Global Quote\" ][ \"05. price\" ] dot = raw_price . index ( \".\" ) return raw_price [: dot + 3 ] agent . serve ( \"stockquote\" ) This is the entire code for the stock quote Agent. The code manifest consists of a set of few-shot examples (example queries and responses), coupled with a little bit of Python code that knows how to invoke an external API to fetch a stock quote. With Code Shots, the Agents functionality is partitioned across two domains: the language processing (done centrally, by Fixie), and the low-level Func invocations (done within the Agent's own sandbox, either in the customers infrastructure or within an environment that is hosted by us). Because a Func does not need to perform any language processing, it is just a simple function! Let\u2019s walk through what happens when a query comes into a Code Shot Agent. The Agent gets a query like \"What is the stock price for GOOG?\" Fixie takes the users query, along with the few-shot examples in the Code Shots manifest, and passes them to a LLM for processing. Note that this language processing is being done centrally, by Fixie, meaning we can automatically select the best LLM and prompt to handle the query, as well as augment the prompt with relevant context and session history. 3. In this case, the output of the LLM will be something like Ask Func[quote]: GOOG . This is basically saying that Fixie needs to invoke this low-level Func to perform the next step of processing. Fixie invokes the Func by sending a REST call over HTTP to the Agents URL, and getting back the response. Fixie then feeds the Funcs response back into the LLM, again with the appropriate prompt and context, to continue processing the query. In this case, the LLM will generate a response like \"A: The share price for GOOG is $105.22\" . 5. The final reply is sent back to the client, or the Agent that issued the original query. There are a few key things to note about Code Shots. First, they make it really easy to build new Agents, since the only thing the developer needs to do is write a few English-language examples of what the Agent does, along with, possibly, one or more simple Funcs that hook into the query processing logic. Second, Funcs need not be private to individual Agents: We are building an entire library of Funcs that Agents can use, including Funcs that evaluate simple computational expressions, fetch data over HTTP, and so forth. Many Agents can be built without implementing any new Funcs, just by calling existing ones.","title":"Code Shot Agents"},{"location":"architecture/#registering-an-agent","text":"Fixie users can create and register their own Agents in the system either via the GraphQL API or through the web interface. The only thing needed to create an Agent is to give it a name, a short description of what it does, and a URL to which Agent queries should be sent.","title":"Registering an Agent"},{"location":"architecture/#authentication","text":"Fixie ensures that all requests flowing through the system are associated with an end user. A user can get a Fixie account by visiting the web UI (https://app.fixie.ai) and signing up using email, a Google account, or a GitHub account. To access the Fixie GraphQL API, the user can get an API key from their profile page on the site. The API key must be provided in an Authorization: Bearer header when making API calls. The API key itself is a JWT, signed by the Fixie service, that identifies the user associated with the query. When Fixie sends a request to an Agent, the request carries with it a JWT (again, signed by Fixie) that identifies the user and the chat session ID. The Agent can verify that an incoming query is in fact coming from Fixie by checking the signature of this JWT. When the Agent wishes to send a query to another Agent, or invoke one of the API endpoints provided by Fixie, it must provide this JWT to prove that the request is being made in the context of an actual user query.","title":"Authentication"},{"location":"architecture/#usage-limits","text":"Fixie imposes generous usage limits on individual users and Agents to prevent abuse. We currently have a per-user daily limit of 1000 queries. If this turns out not to be adequate we can raise the limit or allow users to purchase additional credits. Agents invoking Fixie APIs, such as the User Storage mechanism described below, also have a rate limit on those calls. Code Shot Agents that use Fixies language processing capabilities will additionally have a limit on the number of tokens they can pass through the Fixie-provided LLM API in a given time period.","title":"Usage limits"},{"location":"architecture/#user-storage","text":"Agents often need to maintain state associated with a given user or chat session in which they are involved. While Agents could simply implement their own mechanism for this (e.g., writing data to a database or a cloud storage bucket), we provide a simple API in Fixie for this purpose. Fixies User Storage component is a simple key-value store, allowing Agents to store and retrieve binary blobs associated with an Agent-provided key. This is akin to cookies in a browser context, allowing Agents to stash away information that they might need to access later.","title":"User Storage"},{"location":"cli/","text":"Fixie CLI Reference This page provides documentation for the Fixie command line tool. fixie Command-line interface to the Fixie platform. Usage: fixie [ OPTIONS ] COMMAND [ ARGS ] ... Options: -- help Show this message and exit . agent Agent-related commands. Usage: fixie agent [ OPTIONS ] COMMAND [ ARGS ] ... Options: -- help Show this message and exit . delete Delete an agent. Usage: fixie agent delete [ OPTIONS ] HANDLE Options: -- help Show this message and exit . deploy Deploy the current agent. Usage: fixie agent deploy [ OPTIONS ] [ PATH ] Options: -- metadata - only Only publish metadata and refresh , do not redeploy . -- validate / -- no - validate ( default enabled ) Validate that the agent loads in a local venv before deploying -- help Show this message and exit . init Creates an agent.yaml file. Usage: fixie agent init [ OPTIONS ] Options: -- handle TEXT -- description TEXT -- entry - point TEXT -- more - info - url TEXT -- public BOOLEAN -- requirement TEXT Additional requirements for requirements . txt . Can be specified multiple times . -- help Show this message and exit . list List agents. Usage: fixie agent list [ OPTIONS ] Options: -- verbose Enable verbose output . -- help Show this message and exit . serve Serve the current agent locally via a publicly-accessible URL. Usage: fixie agent serve [ OPTIONS ] [ PATH ] Options: -- host TEXT -- port INTEGER -- tunnel / -- no - tunnel ( default enabled ) Create a tunnel using localhost . run . -- reload / -- no - reload ( default enabled ) Reload automatically . -- venv / -- no - venv Run from virtual environment -- help Show this message and exit . show Show an agent. Usage: fixie agent show [ OPTIONS ] AGENT_ID Options: -- help Show this message and exit . auth Authorizes fixie to access Fixie platform. Usage: fixie auth [ OPTIONS ] Options: -- force Forces authentication , even if the user is authenticated . -- help Show this message and exit . deploy Deploy the current agent. Usage: fixie deploy [ OPTIONS ] [ PATH ] Options: -- metadata - only Only publish metadata and refresh , do not redeploy . -- validate / -- no - validate ( default enabled ) Validate that the agent loads in a local venv before deploying -- help Show this message and exit . init Creates an agent.yaml file. Usage: fixie init [ OPTIONS ] Options: -- handle TEXT -- description TEXT -- entry - point TEXT -- more - info - url TEXT -- public BOOLEAN -- requirement TEXT Additional requirements for requirements . txt . Can be specified multiple times . -- help Show this message and exit . new Creates a new session and opens it. Usage: fixie new [ OPTIONS ] [ MESSAGE ] Options: -- web Open the session in the web interface . - a , -- agent TEXT A specific agent to talk to . If unset , `fixie` is used . -- help Show this message and exit . serve Serve the current agent locally via a publicly-accessible URL. Usage: fixie serve [ OPTIONS ] [ PATH ] Options: -- host TEXT -- port INTEGER -- tunnel / -- no - tunnel ( default enabled ) Create a tunnel using localhost . run . -- reload / -- no - reload ( default enabled ) Reload automatically . -- venv / -- no - venv Run from virtual environment -- help Show this message and exit . session Session-related commands. Usage: fixie session [ OPTIONS ] COMMAND [ ARGS ] ... Options: -- help Show this message and exit . list Lists sessions. Usage: fixie session list [ OPTIONS ] Options: -- help Show this message and exit . new Creates a new session and opens it. Usage: fixie session new [ OPTIONS ] [ MESSAGE ] Options: -- web Open the session in the web interface . - a , -- agent TEXT A specific agent to talk to . If unset , `fixie` is used . -- help Show this message and exit . open Opens a session. Usage: fixie session open [ OPTIONS ] SESSION_ID Options: -- web Open the session in the web interface . -- help Show this message and exit .","title":"CLI"},{"location":"cli/#fixie-cli-reference","text":"This page provides documentation for the Fixie command line tool.","title":"Fixie CLI Reference"},{"location":"cli/#fixie","text":"Command-line interface to the Fixie platform. Usage: fixie [ OPTIONS ] COMMAND [ ARGS ] ... Options: -- help Show this message and exit .","title":"fixie"},{"location":"cli/#agent","text":"Agent-related commands. Usage: fixie agent [ OPTIONS ] COMMAND [ ARGS ] ... Options: -- help Show this message and exit .","title":"agent"},{"location":"cli/#delete","text":"Delete an agent. Usage: fixie agent delete [ OPTIONS ] HANDLE Options: -- help Show this message and exit .","title":"delete"},{"location":"cli/#deploy","text":"Deploy the current agent. Usage: fixie agent deploy [ OPTIONS ] [ PATH ] Options: -- metadata - only Only publish metadata and refresh , do not redeploy . -- validate / -- no - validate ( default enabled ) Validate that the agent loads in a local venv before deploying -- help Show this message and exit .","title":"deploy"},{"location":"cli/#init","text":"Creates an agent.yaml file. Usage: fixie agent init [ OPTIONS ] Options: -- handle TEXT -- description TEXT -- entry - point TEXT -- more - info - url TEXT -- public BOOLEAN -- requirement TEXT Additional requirements for requirements . txt . Can be specified multiple times . -- help Show this message and exit .","title":"init"},{"location":"cli/#list","text":"List agents. Usage: fixie agent list [ OPTIONS ] Options: -- verbose Enable verbose output . -- help Show this message and exit .","title":"list"},{"location":"cli/#serve","text":"Serve the current agent locally via a publicly-accessible URL. Usage: fixie agent serve [ OPTIONS ] [ PATH ] Options: -- host TEXT -- port INTEGER -- tunnel / -- no - tunnel ( default enabled ) Create a tunnel using localhost . run . -- reload / -- no - reload ( default enabled ) Reload automatically . -- venv / -- no - venv Run from virtual environment -- help Show this message and exit .","title":"serve"},{"location":"cli/#show","text":"Show an agent. Usage: fixie agent show [ OPTIONS ] AGENT_ID Options: -- help Show this message and exit .","title":"show"},{"location":"cli/#auth","text":"Authorizes fixie to access Fixie platform. Usage: fixie auth [ OPTIONS ] Options: -- force Forces authentication , even if the user is authenticated . -- help Show this message and exit .","title":"auth"},{"location":"cli/#deploy_1","text":"Deploy the current agent. Usage: fixie deploy [ OPTIONS ] [ PATH ] Options: -- metadata - only Only publish metadata and refresh , do not redeploy . -- validate / -- no - validate ( default enabled ) Validate that the agent loads in a local venv before deploying -- help Show this message and exit .","title":"deploy"},{"location":"cli/#init_1","text":"Creates an agent.yaml file. Usage: fixie init [ OPTIONS ] Options: -- handle TEXT -- description TEXT -- entry - point TEXT -- more - info - url TEXT -- public BOOLEAN -- requirement TEXT Additional requirements for requirements . txt . Can be specified multiple times . -- help Show this message and exit .","title":"init"},{"location":"cli/#new","text":"Creates a new session and opens it. Usage: fixie new [ OPTIONS ] [ MESSAGE ] Options: -- web Open the session in the web interface . - a , -- agent TEXT A specific agent to talk to . If unset , `fixie` is used . -- help Show this message and exit .","title":"new"},{"location":"cli/#serve_1","text":"Serve the current agent locally via a publicly-accessible URL. Usage: fixie serve [ OPTIONS ] [ PATH ] Options: -- host TEXT -- port INTEGER -- tunnel / -- no - tunnel ( default enabled ) Create a tunnel using localhost . run . -- reload / -- no - reload ( default enabled ) Reload automatically . -- venv / -- no - venv Run from virtual environment -- help Show this message and exit .","title":"serve"},{"location":"cli/#session","text":"Session-related commands. Usage: fixie session [ OPTIONS ] COMMAND [ ARGS ] ... Options: -- help Show this message and exit .","title":"session"},{"location":"cli/#list_1","text":"Lists sessions. Usage: fixie session list [ OPTIONS ] Options: -- help Show this message and exit .","title":"list"},{"location":"cli/#new_1","text":"Creates a new session and opens it. Usage: fixie session new [ OPTIONS ] [ MESSAGE ] Options: -- web Open the session in the web interface . - a , -- agent TEXT A specific agent to talk to . If unset , `fixie` is used . -- help Show this message and exit .","title":"new"},{"location":"cli/#open","text":"Opens a session. Usage: fixie session open [ OPTIONS ] SESSION_ID Options: -- web Open the session in the web interface . -- help Show this message and exit .","title":"open"},{"location":"developer-preview/","text":"Welcome to the Fixie Developer Preview Welcome to Fixie! We're happy you're here. We wanted to give you a brief overview of how things work and where to get help if you need stuck. We strongly recommend joining the community on Discord . The entire Fixie team is on hand ready to answer questions and help you if you get stuck. For the Developer Preview Period, there is no charge to use Fixie, but you are limited to 1,000 Fixie queries per day. If you need more, or are interested in use-cases for business, please reach out at hello@fixie.ai and we can help. If you're just getting started, you'll probably want to check out our agent examples repo along with exploring the rest of the docs on this site. Lastly, just a reminder that Fixie is evolving rapidly, so expect a few bugs here and there. Please let us know when you run into these, and we'll do our best to fix them ASAP. Also, is there something you can't do but you'd like to? Let us know! We love feature requests.","title":"Developer preview"},{"location":"developer-preview/#welcome-to-the-fixie-developer-preview","text":"Welcome to Fixie! We're happy you're here. We wanted to give you a brief overview of how things work and where to get help if you need stuck. We strongly recommend joining the community on Discord . The entire Fixie team is on hand ready to answer questions and help you if you get stuck. For the Developer Preview Period, there is no charge to use Fixie, but you are limited to 1,000 Fixie queries per day. If you need more, or are interested in use-cases for business, please reach out at hello@fixie.ai and we can help. If you're just getting started, you'll probably want to check out our agent examples repo along with exploring the rest of the docs on this site. Lastly, just a reminder that Fixie is evolving rapidly, so expect a few bugs here and there. Please let us know when you run into these, and we'll do our best to fix them ASAP. Also, is there something you can't do but you'd like to? Let us know! We love feature requests.","title":"Welcome to the Fixie Developer Preview"},{"location":"docs-readme/","text":"To add a new theme run the following commands: poetry add theme-name just install just serve-docs Make sure the new theme name is used in mkdocs.yml file under theme/name. You should be able to checkout the docs on local page at http://127.0.0.1:8000/","title":"Docs readme"},{"location":"python-agent-api/","text":"Fixie Agent Python API Reference This module holds objects that represent the API interface by which Agents talk to Fixie ecosystem. AgentQuery A standalone query sent to a Fixie agent. Source code in fixieai/agents/api.py 58 59 60 61 62 63 64 65 66 67 68 69 @pydantic_dataclasses . dataclass class AgentQuery : \"\"\"A standalone query sent to a Fixie agent.\"\"\" # The contents of the query. message : Message # This is an access token associated with the user for whom this query was # created. Agents wishing to make queries to other agents, or to other # Fixie services, should carry this token in the query so that it # can be tied back to the original user. access_token : Optional [ str ] = None AgentResponse A response message from an Agent. Source code in fixieai/agents/api.py 72 73 74 75 76 77 @pydantic_dataclasses . dataclass class AgentResponse : \"\"\"A response message from an Agent.\"\"\" # The text of the response message. message : Message Embed An Embed represents a binary object attached to a Message. Source code in fixieai/agents/api.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 @pydantic_dataclasses . dataclass class Embed : \"\"\"An Embed represents a binary object attached to a Message.\"\"\" # The MIME content type of the object, e.g., \"image/png\" or \"application/json\". content_type : str # A public URL where the object can be downloaded. This can be a data URI. uri : str @property def content ( self ) -> bytes : \"\"\"Retrieves the content for this Embed object.\"\"\" if self . uri . startswith ( \"data:\" ): return base64 . b64decode ( self . uri . split ( \",\" )[ 1 ]) return requests . get ( self . uri ) . content @content . setter def content ( self , content : bytes ): \"\"\"Sets the content of the Embed object as a data URI.\"\"\" self . uri = f \"data:base64, { base64 . b64encode ( content ) . decode ( 'utf-8' ) } \" @property def text ( self ) -> str : \"\"\"Retrieves the content of the Embed object as a string.\"\"\" return self . content . decode ( \"utf-8\" ) @text . setter def text ( self , text : str ): \"\"\"Sets the content of the Embed object as a string.\"\"\" self . content = text . encode ( \"utf-8\" ) content : bytes writable property Retrieves the content for this Embed object. text : str writable property Retrieves the content of the Embed object as a string. Message A Message represents a single message sent to a Fixie agent. Source code in fixieai/agents/api.py 47 48 49 50 51 52 53 54 55 @pydantic_dataclasses . dataclass class Message : \"\"\"A Message represents a single message sent to a Fixie agent.\"\"\" # The text of the message. text : str # A mapping of embed keys to Embed objects. embeds : Dict [ str , Embed ] = dataclasses . field ( default_factory = dict ) AgentMetadata Metadata for a Fixie CodeShot Agent. This will get sent to the Fixie platform upon handshake. Source code in fixieai/agents/code_shot.py 62 63 64 65 66 67 68 69 70 71 72 73 @pydantic_dataclasses . dataclass class AgentMetadata : \"\"\"Metadata for a Fixie CodeShot Agent. This will get sent to the Fixie platform upon handshake. \"\"\" base_prompt : str few_shots : List [ str ] corpora : Optional [ List [ corpora . DocumentCorpus ]] = None conversational : bool = False response_model : Optional [ LlmSettings ] = None CodeShotAgent A CodeShot agent. To make a CodeShot agent, simply pass a BASE_PROMPT and FEW_SHOTS: BASE_PROMPT = \"A summary of what this agent does; how it does it; and its personality \" FEW_SHOTS = ''' Q: <Sample query that this agent supports> A: <Desired response for this query> Q: <Another sample query> A: <Desired response for this query> ''' agent = CodeShotAgent(BASE_PROMPT, FEW_SHOTS) You can have FEW_SHOTS as a single string of all your few-shots separated by 2 new lines, or as an explicit list of one few-shot per index. Your few-shots may reach out to other Agents in the fixie ecosystem by \"Ask Agent[agent_id]: \", or reach out to some python functions by \"Ask Func[func_name]: \". There are a series of default runtime Func s provided by the platform available for your agents to consume. For a full list of default runtime Func s, refer to: http://docs.fixie.ai/XXX You may also need to write your own python functions here to be consumed by your agent. To make a function accessible by an agent, you'd need to register it by @agent.register_func . Example: @agent.register_func def func_name ( query : fixieai . Message ) -> ReturnType : ... , where ReturnType is one of `str` , `fixieai.Message` , or `fixie.AgentResponse` . Note that in the above, we are using the decorator @agent.register_func to register this function with the agent instance we just created. To check out the default Func s that are provided in Fixie, see: http://docs.fixie.ai/XXX Source code in fixieai/agents/code_shot.py 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 class CodeShotAgent : \"\"\"A CodeShot agent. To make a CodeShot agent, simply pass a BASE_PROMPT and FEW_SHOTS: BASE_PROMPT = \"A summary of what this agent does; how it does it; and its personality\" FEW_SHOTS = ''' Q: <Sample query that this agent supports> A: <Desired response for this query> Q: <Another sample query> A: <Desired response for this query> ''' agent = CodeShotAgent(BASE_PROMPT, FEW_SHOTS) You can have FEW_SHOTS as a single string of all your few-shots separated by 2 new lines, or as an explicit list of one few-shot per index. Your few-shots may reach out to other Agents in the fixie ecosystem by \"Ask Agent[agent_id]: <query to pass>\", or reach out to some python functions by \"Ask Func[func_name]: <query to pass>\". There are a series of default runtime `Func`s provided by the platform available for your agents to consume. For a full list of default runtime `Func`s, refer to: http://docs.fixie.ai/XXX You may also need to write your own python functions here to be consumed by your agent. To make a function accessible by an agent, you'd need to register it by `@agent.register_func`. Example: @agent.register_func def func_name(query: fixieai.Message) -> ReturnType: ... , where ReturnType is one of `str`, `fixieai.Message`, or `fixie.AgentResponse`. Note that in the above, we are using the decorator `@agent.register_func` to register this function with the agent instance we just created. To check out the default `Func`s that are provided in Fixie, see: http://docs.fixie.ai/XXX \"\"\" def __init__ ( self , base_prompt : str , few_shots : Union [ str , List [ str ]], corpora : Optional [ List [ corpora . DocumentCorpus ]] = None , conversational : bool = False , oauth_params : Optional [ oauth . OAuthParams ] = None , llm_settings : Optional [ LlmSettings ] = None , ): if isinstance ( few_shots , str ): few_shots = _split_few_shots ( few_shots ) self . base_prompt = base_prompt self . few_shots = few_shots self . corpora = corpora self . conversational = conversational self . oauth_params = oauth_params self . llm_settings = llm_settings self . _funcs : Dict [ str , Callable ] = {} self . _jwks_client = jwt . PyJWKClient ( constants . FIXIE_JWKS_URL ) self . _allowed_agent_id = os . getenv ( \"FIXIE_ALLOWED_AGENT_ID\" ) if self . _allowed_agent_id is None : warnings . warn ( \"No allowed agent ID was specified, so your agent will accept requests intended for any agent. \" \"Ensure that the FIXIE_ALLOWED_AGENT_ID variable is set to correct this.\" ) if oauth_params is not None : # Register default Funcs. self . register_func ( _oauth ) utils . strip_prompt_lines ( self ) def serve ( self , host : str = \"0.0.0.0\" , port : int = 8181 ): \"\"\"Starts serving the current agent at `{host}:{port}` via uvicorn. Args: host: The address to start listening at. port: The port number to start listening at. \"\"\" uvicorn . run ( self . app (), host = host , port = port ) def app ( self ) -> fastapi . FastAPI : \"\"\"Returns a fastapi.FastAPI application that serves the agent.\"\"\" fast_api = fastapi . FastAPI () fast_api . include_router ( self . api_router ()) return fast_api def api_router ( self ) -> fastapi . APIRouter : \"\"\"Returns a fastapi.APIRouter object that serves the agent.\"\"\" router = fastapi . APIRouter () router . add_api_route ( \"/\" , self . _handshake , methods = [ \"GET\" ]) router . add_api_route ( \"/ {func_name} \" , self . _serve_func , methods = [ \"POST\" ]) return router def is_valid_func_name ( self , func_name : str ) -> bool : \"\"\"Indicates if the given func name is valid (either registered or built-in). Args: func_name: The func name to check \"\"\" return func_name in self . _funcs or func_name . startswith ( \"fixie_\" ) def register_func ( self , func : Optional [ Callable ] = None , * , func_name : Optional [ str ] = None ) -> Callable : \"\"\"A function decorator to register `Func`s with this agent. This decorator will not change the callable itself. Usage: agent = CodeShotAgent(base_prompt, few_shots) @agent.register_func def func(query): ... Optional Decorator Args: func_name: Optional function name to register this function by. If unset, the function name will be used. \"\"\" if func is None : # Func is not passed in. It's the decorator being created. return functools . partial ( self . register_func , func_name = func_name ) if func_name is not None : if not ACCEPTED_FUNC_NAMES . fullmatch ( func_name ): raise ValueError ( f \"Function names may only be alphanumerics, got { func_name !r} .\" ) utils . validate_registered_pyfunc ( func , self ) name = func_name or func . __name__ if name in self . _funcs : raise ValueError ( f \"Func[ { name } ] is already registered with agent.\" ) self . _funcs [ name ] = func return func def _handshake ( self , credentials : fastapi . security . HTTPAuthorizationCredentials = fastapi . Depends ( fastapi . security . HTTPBearer () ), ) -> fastapi . Response : \"\"\"Returns the agent's metadata in YAML format.\"\"\" token_claims = _VerifiedTokenClaims . from_token ( credentials . credentials , self . _jwks_client , self . _allowed_agent_id ) if token_claims is None : raise fastapi . HTTPException ( status_code = 403 , detail = \"Invalid token\" ) metadata = AgentMetadata ( self . base_prompt , self . few_shots , self . corpora , self . conversational , self . llm_settings , ) yaml_content = yaml . dump ( dataclasses . asdict ( metadata )) # Use a streaming response because prompts/fewshots can be very large. chunks = ( yaml_content [ start : start + _RESPONSE_CHUNK_SIZE ] for start in range ( 0 , len ( yaml_content ), _RESPONSE_CHUNK_SIZE ) ) return starlette . responses . StreamingResponse ( chunks , media_type = \"application/yaml\" , ) def _serve_func ( self , func_name : str , query : api . AgentQuery , credentials : fastapi . security . HTTPAuthorizationCredentials = fastapi . Depends ( fastapi . security . HTTPBearer () ), ) -> api . AgentResponse : \"\"\"Verifies the request is a valid request from Fixie, and dispatches it to the appropriate function. \"\"\" token_claims = _VerifiedTokenClaims . from_token ( credentials . credentials , self . _jwks_client , self . _allowed_agent_id ) if token_claims is None : raise fastapi . HTTPException ( status_code = 403 , detail = \"Invalid token\" ) elif ( query . access_token is not None and query . access_token != credentials . credentials ): raise fastapi . HTTPException ( status_code = 403 , detail = \"Mismatched tokens\" ) else : query . access_token = credentials . credentials try : pyfunc = self . _funcs [ func_name ] except KeyError : raise fastapi . HTTPException ( status_code = 404 , detail = f \"Func[ { func_name } ] doesn't exist\" ) kwargs = self . _get_func_kwargs ( query , token_claims , inspect . signature ( pyfunc ) . parameters . keys () ) output = pyfunc ( ** kwargs ) try : return _wrap_with_agent_response ( output ) except TypeError : raise TypeError ( f \"Func[ { func_name } ] returned unexpected output of type { type ( output ) } .\" ) def _get_func_kwargs ( self , query : api . AgentQuery , token_claims : _VerifiedTokenClaims , arg_names : Iterable [ str ], ) -> Dict [ str , Any ]: kwargs : Dict [ str , Any ] = {} for arg_name in arg_names : if arg_name == \"query\" : kwargs [ arg_name ] = query . message elif arg_name == \"user_storage\" : kwargs [ arg_name ] = user_storage . UserStorage ( query , token_claims . agent_id ) elif arg_name == \"oauth_handler\" : assert self . oauth_params , \"oauth_params is not set\" kwargs [ arg_name ] = oauth . OAuthHandler ( self . oauth_params , query , token_claims . agent_id ) else : raise ValueError ( f \"Found unknown argument { arg_name !r} .\" ) return kwargs api_router () Returns a fastapi.APIRouter object that serves the agent. Source code in fixieai/agents/code_shot.py 171 172 173 174 175 176 def api_router ( self ) -> fastapi . APIRouter : \"\"\"Returns a fastapi.APIRouter object that serves the agent.\"\"\" router = fastapi . APIRouter () router . add_api_route ( \"/\" , self . _handshake , methods = [ \"GET\" ]) router . add_api_route ( \"/ {func_name} \" , self . _serve_func , methods = [ \"POST\" ]) return router app () Returns a fastapi.FastAPI application that serves the agent. Source code in fixieai/agents/code_shot.py 165 166 167 168 169 def app ( self ) -> fastapi . FastAPI : \"\"\"Returns a fastapi.FastAPI application that serves the agent.\"\"\" fast_api = fastapi . FastAPI () fast_api . include_router ( self . api_router ()) return fast_api is_valid_func_name ( func_name ) Indicates if the given func name is valid (either registered or built-in). Parameters: Name Type Description Default func_name str The func name to check required Source code in fixieai/agents/code_shot.py 178 179 180 181 182 183 184 def is_valid_func_name ( self , func_name : str ) -> bool : \"\"\"Indicates if the given func name is valid (either registered or built-in). Args: func_name: The func name to check \"\"\" return func_name in self . _funcs or func_name . startswith ( \"fixie_\" ) register_func ( func = None , * , func_name = None ) A function decorator to register Func s with this agent. This decorator will not change the callable itself. Usage agent = CodeShotAgent(base_prompt, few_shots) @agent.register_func def func(query): ... Optional Decorator Args func_name: Optional function name to register this function by. If unset, the function name will be used. Source code in fixieai/agents/code_shot.py 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 def register_func ( self , func : Optional [ Callable ] = None , * , func_name : Optional [ str ] = None ) -> Callable : \"\"\"A function decorator to register `Func`s with this agent. This decorator will not change the callable itself. Usage: agent = CodeShotAgent(base_prompt, few_shots) @agent.register_func def func(query): ... Optional Decorator Args: func_name: Optional function name to register this function by. If unset, the function name will be used. \"\"\" if func is None : # Func is not passed in. It's the decorator being created. return functools . partial ( self . register_func , func_name = func_name ) if func_name is not None : if not ACCEPTED_FUNC_NAMES . fullmatch ( func_name ): raise ValueError ( f \"Function names may only be alphanumerics, got { func_name !r} .\" ) utils . validate_registered_pyfunc ( func , self ) name = func_name or func . __name__ if name in self . _funcs : raise ValueError ( f \"Func[ { name } ] is already registered with agent.\" ) self . _funcs [ name ] = func return func serve ( host = '0.0.0.0' , port = 8181 ) Starts serving the current agent at {host}:{port} via uvicorn. Parameters: Name Type Description Default host str The address to start listening at. '0.0.0.0' port int The port number to start listening at. 8181 Source code in fixieai/agents/code_shot.py 156 157 158 159 160 161 162 163 def serve ( self , host : str = \"0.0.0.0\" , port : int = 8181 ): \"\"\"Starts serving the current agent at `{host}:{port}` via uvicorn. Args: host: The address to start listening at. port: The port number to start listening at. \"\"\" uvicorn . run ( self . app (), host = host , port = port ) LlmSettings LLM settings for agents. These settings influence how agent responses are generated by the underlying LLM. Parameters: Name Type Description Default model Optional [ str ] The name of the LLM to use. See https://docs.fixie.ai/agents/#agent-default-model-and-model-params for supported values. required temperature Optional [ float ] The sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic. The precise behavior is model-specific. required maximum_tokens Optional [ int ] The maximum number of tokens to generate in responses. One token is typically a subword. The exact token definition depends on the model. required Source code in fixieai/agents/code_shot.py 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 @pydantic_dataclasses . dataclass class LlmSettings : \"\"\"LLM settings for agents. These settings influence how agent responses are generated by the underlying LLM. Args: model Optional[str]: The name of the LLM to use. See https://docs.fixie.ai/agents/#agent-default-model-and-model-params for supported values. temperature Optional[float]: The sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic. The precise behavior is model-specific. maximum_tokens Optional[int]: The maximum number of tokens to generate in responses. One token is typically a subword. The exact token definition depends on the model. \"\"\" model : Optional [ str ] = None temperature : Optional [ float ] = None maximum_tokens : Optional [ int ] = None OAuthHandler OAuthHandler that wraps around a (OAuthParams, query) to authenticate. This client object provides 3 main method credentials: Returns current user's OAuth access token, or None if they are not authenticated. get_authorization_url: Returns a url that the users can click to authenticate themselves. authorize: Exchanges a received access code (from auth redirect callback) for an access token. If successful, user's storage is updated. Source code in fixieai/agents/oauth.py 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 class OAuthHandler : \"\"\" OAuthHandler that wraps around a (OAuthParams, query) to authenticate. This client object provides 3 main method: * credentials: Returns current user's OAuth access token, or None if they are not authenticated. * get_authorization_url: Returns a url that the users can click to authenticate themselves. * authorize: Exchanges a received access code (from auth redirect callback) for an access token. If successful, user's storage is updated. \"\"\" # OAuth keys reserved in UserStorage OAUTH_STATE_KEY = \"_oauth_state\" OAUTH_TOKEN_KEY = \"_oauth_token\" def __init__ ( self , oauth_params : OAuthParams , query : api . AgentQuery , agent_id : str , ): self . _storage = user_storage . UserStorage ( query , agent_id ) self . _oauth_params = oauth_params self . _agent_id = agent_id def get_authorization_url ( self ) -> str : \"\"\"Returns a URL to launch the authorization flow.\"\"\" auth_state = f \" { self . _agent_id } : { secrets . token_urlsafe () } \" data = { \"response_type\" : \"code\" , \"access_type\" : \"offline\" , \"client_id\" : self . _oauth_params . client_id , \"scope\" : \" \" . join ( self . _oauth_params . scopes ), \"state\" : auth_state , \"redirect_uri\" : constants . FIXIE_OAUTH_REDIRECT_URL , } url = self . _oauth_params . auth_uri + \"?\" + parse . urlencode ( data ) # Store auth_state in UserStorage for validation later. self . _storage [ self . OAUTH_STATE_KEY ] = auth_state return url def user_token ( self ) -> Optional [ str ]: \"\"\"Returns current user's OAuth credentials, or None if not authorized.\"\"\" try : creds_json = self . _storage [ self . OAUTH_TOKEN_KEY ] except KeyError : return None if not isinstance ( creds_json , str ): logging . warning ( f \"Value at user_storage[ { self . OAUTH_TOKEN_KEY !r} ] is \" f \"not an OAuthCredentials json: { creds_json !r} \" ) del self . _storage [ self . OAUTH_TOKEN_KEY ] return None try : creds = _OAuthCredentials . from_json ( creds_json ) except ( TypeError , LookupError , ValueError ): logging . warning ( f \"Value at user_storage[ { self . OAUTH_TOKEN_KEY !r} ] is \" f \"not a valid _OAuthCredentials json: { creds_json !r} \" ) del self . _storage [ self . OAUTH_TOKEN_KEY ] return None if creds . expired : logging . debug ( f \"Credentials expired at { creds . expiry } \" ) if not creds . refresh_token : logging . warning ( \"No refresh token available\" ) return None logging . debug ( \"Refreshing credentials...\" ) creds . refresh ( self . _oauth_params ) self . _save_credentials ( creds ) # Save refreshed token to UserStorage return creds . access_token def authorize ( self , state : str , code : str ): \"\"\"Authorize the received access `code` against the client secret. If successful, the credentials will be saved in user storage. \"\"\" expected_state = self . _storage [ self . OAUTH_STATE_KEY ] if state != expected_state : logging . warning ( f \"Unknown state token, expected: { expected_state !r} actual: { state !r} \" ) raise ValueError ( f \"Unknown state token\" ) data = { \"grant_type\" : \"authorization_code\" , \"client_id\" : self . _oauth_params . client_id , \"client_secret\" : self . _oauth_params . client_secret , \"code\" : code , \"redirect_uri\" : constants . FIXIE_OAUTH_REDIRECT_URL , } response = _send_authorize_request ( self . _oauth_params . token_uri , data ) logging . debug ( f \"OAuth auth request succeeded, lifetime= { response . expires_in } \" f \"refreshable= { response . refresh_token is not None } \" ) credentials = _OAuthCredentials ( response . access_token , _get_expiry ( response . expires_in ), response . refresh_token , ) self . _save_credentials ( credentials ) def _save_credentials ( self , credentials : \"_OAuthCredentials\" ): self . _storage [ self . OAUTH_TOKEN_KEY ] = credentials . to_json () authorize ( state , code ) Authorize the received access code against the client secret. If successful, the credentials will be saved in user storage. Source code in fixieai/agents/oauth.py 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 def authorize ( self , state : str , code : str ): \"\"\"Authorize the received access `code` against the client secret. If successful, the credentials will be saved in user storage. \"\"\" expected_state = self . _storage [ self . OAUTH_STATE_KEY ] if state != expected_state : logging . warning ( f \"Unknown state token, expected: { expected_state !r} actual: { state !r} \" ) raise ValueError ( f \"Unknown state token\" ) data = { \"grant_type\" : \"authorization_code\" , \"client_id\" : self . _oauth_params . client_id , \"client_secret\" : self . _oauth_params . client_secret , \"code\" : code , \"redirect_uri\" : constants . FIXIE_OAUTH_REDIRECT_URL , } response = _send_authorize_request ( self . _oauth_params . token_uri , data ) logging . debug ( f \"OAuth auth request succeeded, lifetime= { response . expires_in } \" f \"refreshable= { response . refresh_token is not None } \" ) credentials = _OAuthCredentials ( response . access_token , _get_expiry ( response . expires_in ), response . refresh_token , ) self . _save_credentials ( credentials ) get_authorization_url () Returns a URL to launch the authorization flow. Source code in fixieai/agents/oauth.py 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 def get_authorization_url ( self ) -> str : \"\"\"Returns a URL to launch the authorization flow.\"\"\" auth_state = f \" { self . _agent_id } : { secrets . token_urlsafe () } \" data = { \"response_type\" : \"code\" , \"access_type\" : \"offline\" , \"client_id\" : self . _oauth_params . client_id , \"scope\" : \" \" . join ( self . _oauth_params . scopes ), \"state\" : auth_state , \"redirect_uri\" : constants . FIXIE_OAUTH_REDIRECT_URL , } url = self . _oauth_params . auth_uri + \"?\" + parse . urlencode ( data ) # Store auth_state in UserStorage for validation later. self . _storage [ self . OAUTH_STATE_KEY ] = auth_state return url user_token () Returns current user's OAuth credentials, or None if not authorized. Source code in fixieai/agents/oauth.py 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 def user_token ( self ) -> Optional [ str ]: \"\"\"Returns current user's OAuth credentials, or None if not authorized.\"\"\" try : creds_json = self . _storage [ self . OAUTH_TOKEN_KEY ] except KeyError : return None if not isinstance ( creds_json , str ): logging . warning ( f \"Value at user_storage[ { self . OAUTH_TOKEN_KEY !r} ] is \" f \"not an OAuthCredentials json: { creds_json !r} \" ) del self . _storage [ self . OAUTH_TOKEN_KEY ] return None try : creds = _OAuthCredentials . from_json ( creds_json ) except ( TypeError , LookupError , ValueError ): logging . warning ( f \"Value at user_storage[ { self . OAUTH_TOKEN_KEY !r} ] is \" f \"not a valid _OAuthCredentials json: { creds_json !r} \" ) del self . _storage [ self . OAUTH_TOKEN_KEY ] return None if creds . expired : logging . debug ( f \"Credentials expired at { creds . expiry } \" ) if not creds . refresh_token : logging . warning ( \"No refresh token available\" ) return None logging . debug ( \"Refreshing credentials...\" ) creds . refresh ( self . _oauth_params ) self . _save_credentials ( creds ) # Save refreshed token to UserStorage return creds . access_token OAuthParams dataclass Encapsulates OAuth parameters, including secret, auth uri, and the scope. Agents who want to use OAuth flow, should declare their secrets via this object. Source code in fixieai/agents/oauth.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 @dataclasses . dataclass class OAuthParams : \"\"\"Encapsulates OAuth parameters, including secret, auth uri, and the scope. Agents who want to use OAuth flow, should declare their secrets via this object. \"\"\" client_id : str client_secret : str auth_uri : str token_uri : str scopes : List [ str ] @classmethod def from_client_secrets_file ( cls , secrets_path : str , scopes : List [ str ] ) -> \"OAuthParams\" : \"\"\"Initializes OAuth from a secrets file, e.g., as obtained from the Google Cloud Console. Args: secrets_path: Path to a json file holding secret values. scopes: A list of scopes that access needs to be requested for. \"\"\" with open ( secrets_path , \"r\" ) as file : data = json . load ( file ) secrets = data [ \"web\" ] or data [ \"installed\" ] return cls ( secrets [ \"client_id\" ], secrets [ \"client_secret\" ], secrets [ \"auth_uri\" ], secrets [ \"token_uri\" ], scopes , ) from_client_secrets_file ( secrets_path , scopes ) classmethod Initializes OAuth from a secrets file, e.g., as obtained from the Google Cloud Console. Parameters: Name Type Description Default secrets_path str Path to a json file holding secret values. required scopes List [ str ] A list of scopes that access needs to be requested for. required Source code in fixieai/agents/oauth.py 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 @classmethod def from_client_secrets_file ( cls , secrets_path : str , scopes : List [ str ] ) -> \"OAuthParams\" : \"\"\"Initializes OAuth from a secrets file, e.g., as obtained from the Google Cloud Console. Args: secrets_path: Path to a json file holding secret values. scopes: A list of scopes that access needs to be requested for. \"\"\" with open ( secrets_path , \"r\" ) as file : data = json . load ( file ) secrets = data [ \"web\" ] or data [ \"installed\" ] return cls ( secrets [ \"client_id\" ], secrets [ \"client_secret\" ], secrets [ \"auth_uri\" ], secrets [ \"token_uri\" ], scopes , ) UserStorage Bases: MutableMapping [ str , UserStorageType ] UserStorage provides a dict-like interface to a user-specific storage. Usage: from fixieai import AgentQuery, Message query = AgentQuery( ... Message(\"incoming query\"), ... access_token=\"fake-access-token\" ... ) storage = UserStorage(query, \"fake-agent\") storage[\"key\"] = \"value\" storage[\"complex-key\"] = {\"key1\": {\"key2\": [12, False, None, b\"binary\"]}} assert len(storage) == 2 assert storage \"complex-key\" \"key2\" == b\"binary\" Source code in fixieai/agents/user_storage.py 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 class UserStorage ( MutableMapping [ str , UserStorageType ]): \"\"\"UserStorage provides a dict-like interface to a user-specific storage. Usage: >>> from fixieai import AgentQuery, Message >>> query = AgentQuery( ... Message(\"incoming query\"), ... access_token=\"fake-access-token\" ... ) >>> storage = UserStorage(query, \"fake-agent\") >>> storage[\"key\"] = \"value\" >>> storage[\"complex-key\"] = {\"key1\": {\"key2\": [12, False, None, b\"binary\"]}} >>> assert len(storage) == 2 >>> assert storage[\"complex-key\"][\"key1\"][\"key2\"][-1] == b\"binary\" \"\"\" def __init__ ( self , query : \"AgentQuery\" , agent_id : str , userstorage_url : str = constants . FIXIE_USER_STORAGE_URL , ): # TODO(hessam): Remove agent_id from args once access_token includes agent_id # as well. self . _agent_id = agent_id self . _userstorage_url = userstorage_url self . _session = requests . Session () self . _session . headers . update ({ \"Authorization\" : f \"Bearer { query . access_token } \" }) def __setitem__ ( self , key : str , value : UserStorageType ): url = f \" { self . _userstorage_url } / { self . _agent_id } / { key } \" response = self . _session . post ( url , json = { \"data\" : to_json ( value )}) response . raise_for_status () def __getitem__ ( self , key : str ) -> UserStorageType : url = f \" { self . _userstorage_url } / { self . _agent_id } / { key } \" try : response = self . _session . get ( url ) response . raise_for_status () return from_json ( response . json ()[ \"data\" ]) except requests . exceptions . HTTPError as e : raise KeyError ( f \"Key { key } not found\" ) from e def __contains__ ( self , key : object ) -> bool : url = f \" { self . _userstorage_url } / { self . _agent_id } / { key } \" try : response = self . _session . head ( url ) response . raise_for_status () return True except requests . exceptions . HTTPError as e : return False def __delitem__ ( self , key : str ): url = f \" { self . _userstorage_url } / { self . _agent_id } / { key } \" try : response = self . _session . delete ( url ) response . raise_for_status () except requests . exceptions . HTTPError as e : raise KeyError ( f \"Key { key } not found\" ) from e def _get_all_keys ( self ): url = f \" { self . _userstorage_url } / { self . _agent_id } \" response = self . _session . get ( url ) response . raise_for_status () return [ value [ \"key\" ] for value in response . json ()] def __iter__ ( self ): return iter ( self . _get_all_keys ()) def __len__ ( self ): return len ( self . _get_all_keys ()) from_json ( json_dump ) Deserializes a UserStorageType from a JSON string. Source code in fixieai/agents/user_storage.py 101 102 103 def from_json ( json_dump : str ) -> UserStorageType : \"\"\"Deserializes a UserStorageType from a JSON string.\"\"\" return from_json_type ( json . loads ( json_dump )) from_json_type ( obj ) Decodes a JsonType to UserStorageType. Source code in fixieai/agents/user_storage.py 118 119 120 121 122 123 124 125 126 127 def from_json_type ( obj : JsonType ) -> UserStorageType : \"\"\"Decodes a JsonType to UserStorageType.\"\"\" if _is_bytes_encoded_json_dict ( obj ): return base64 . b64decode ( obj [ \"data\" ]) # type: ignore elif isinstance ( obj , list ): return [ from_json_type ( item ) for item in obj ] elif isinstance ( obj , dict ): return { key : from_json_type ( value ) for key , value in obj . items ()} else : return obj to_json ( obj ) Serialize a UserStorageType to a JSON string. Source code in fixieai/agents/user_storage.py 96 97 98 def to_json ( obj : UserStorageType ) -> str : \"\"\"Serialize a UserStorageType to a JSON string.\"\"\" return json . dumps ( to_json_type ( obj )) to_json_type ( obj ) Encodes a UserStorageType to JsonType. Source code in fixieai/agents/user_storage.py 106 107 108 109 110 111 112 113 114 115 def to_json_type ( obj : UserStorageType ) -> JsonType : \"\"\"Encodes a UserStorageType to JsonType.\"\"\" if isinstance ( obj , bytes ): return { \"type\" : \"_bytes_ascii\" , \"data\" : base64 . b64encode ( obj ) . decode ( \"ASCII\" )} elif isinstance ( obj , list ): return [ to_json_type ( item ) for item in obj ] elif isinstance ( obj , dict ): return { key : to_json_type ( value ) for key , value in obj . items ()} else : return obj FewshotLinePattern Bases: enum . Enum Source code in fixieai/agents/utils.py 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 class FewshotLinePattern ( enum . Enum ): QUERY = re . compile ( r \"^Q:\" ) AGENT_SAYS = re . compile ( r \"^Agent\\[(?P<agent_id>\\w+)] says:\" ) FUNC_SAYS = re . compile ( r \"^Func\\[(?P<func_name>\\w+)] says:\" ) ASK_AGENT = re . compile ( r \"^Ask Agent\\[(?P<agent_id>\\w+)]:\" ) ASK_FUNC = re . compile ( r \"^Ask Func\\[(?P<func_name>\\w+)]:\" ) RESPONSE = re . compile ( r \"^A:\" ) NO_PATTERN : None = None @classmethod def match ( cls , line : str ) -> Optional [ re . Match [ str ]]: \"\"\"Returns a match from a FewshotLinePattern for a given line, or None if nothing matched.\"\"\" if \" \\n \" in line : raise ValueError ( \"Cannot get the pattern for a multi-line text. Patterns must be \" \"extracted one line at a time.\" ) matches = [ match for prompt_pattern in cls if prompt_pattern is not cls . NO_PATTERN and ( match := prompt_pattern . value . match ( line )) ] if len ( matches ) > 1 : raise RuntimeError ( f \"More than one pattern ( { list ( FewshotLinePattern ( match . re ) for match in matches ) } ) matched the line { line !r} .\" ) elif len ( matches ) == 0 : return None match = matches [ 0 ] if match . re is cls . QUERY . value : if match . end () == len ( line ): raise ValueError ( \"A 'Q:' line cannot end without a query.\" ) assert isinstance ( match , re . Match ) return match match ( line ) classmethod Returns a match from a FewshotLinePattern for a given line, or None if nothing matched. Source code in fixieai/agents/utils.py 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 @classmethod def match ( cls , line : str ) -> Optional [ re . Match [ str ]]: \"\"\"Returns a match from a FewshotLinePattern for a given line, or None if nothing matched.\"\"\" if \" \\n \" in line : raise ValueError ( \"Cannot get the pattern for a multi-line text. Patterns must be \" \"extracted one line at a time.\" ) matches = [ match for prompt_pattern in cls if prompt_pattern is not cls . NO_PATTERN and ( match := prompt_pattern . value . match ( line )) ] if len ( matches ) > 1 : raise RuntimeError ( f \"More than one pattern ( { list ( FewshotLinePattern ( match . re ) for match in matches ) } ) matched the line { line !r} .\" ) elif len ( matches ) == 0 : return None match = matches [ 0 ] if match . re is cls . QUERY . value : if match . end () == len ( line ): raise ValueError ( \"A 'Q:' line cannot end without a query.\" ) assert isinstance ( match , re . Match ) return match strip_prompt_lines ( agent ) Strips all prompt lines. Source code in fixieai/agents/utils.py 20 21 22 23 24 def strip_prompt_lines ( agent : code_shot . CodeShotAgent ): \"\"\"Strips all prompt lines.\"\"\" agent . base_prompt = _strip_all_lines ( agent . base_prompt ) for i , fewshot in enumerate ( agent . few_shots ): agent . few_shots [ i ] = _strip_all_lines ( fewshot ) validate_code_shot_agent ( agent ) A client-side validation of few_shots and agent. Source code in fixieai/agents/utils.py 27 28 29 30 31 32 33 def validate_code_shot_agent ( agent : code_shot . CodeShotAgent ): \"\"\"A client-side validation of few_shots and agent.\"\"\" _validate_base_prompt ( agent . base_prompt ) for fewshot in agent . few_shots : _validate_few_shot_prompt ( fewshot , agent . conversational , agent . is_valid_func_name ) validate_registered_pyfunc ( func , agent ) Validates func 's signature to be a valid CodeShot Func. Parameters: Name Type Description Default func Callable The function to be validated. required agent code_shot . CodeShotAgent The CodeShotAgent that this func is going to be registered for. required Source code in fixieai/agents/utils.py 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 def validate_registered_pyfunc ( func : Callable , agent : code_shot . CodeShotAgent ): \"\"\"Validates `func`'s signature to be a valid CodeShot Func. Args: func: The function to be validated. agent: The CodeShotAgent that this func is going to be registered for. \"\"\" # Delayed import to avoid circular dependency from fixieai.agents import api from fixieai.agents import oauth from fixieai.agents import user_storage ALLOWED_FUNC_PARAMS = { \"query\" : api . Message , \"user_storage\" : user_storage . UserStorage , \"oauth_handler\" : oauth . OAuthHandler , } # Validate that func is a function type. if not inspect . isfunction ( func ): raise TypeError ( f \"Registered function { func !r} is not a function, but a { type ( func ) !r} .\" ) signature = inspect . signature ( func ) func_name = func . __name__ params = signature . parameters # Validate that there are not var args (*args or **kwargs). if any ( param . kind in ( param . VAR_KEYWORD , param . VAR_POSITIONAL ) for param in params . values () ): raise TypeError ( f \"Registered function { func_name } cannot accept variable args: { params !r} .\" ) # Validate that all argument names are known. unknown_params = set ( params . keys ()) - set ( ALLOWED_FUNC_PARAMS . keys ()) if unknown_params : raise TypeError ( f \"Registered function { func_name } gets unknown arguments { unknown_params } . \" f \"List of allowed Func arguments are { list ( ALLOWED_FUNC_PARAMS . keys ()) } .\" ) # Check the type annotations match what's expected, if func is type annotated. type_hints = get_type_hints ( func ) for arg_name , arg_type in ALLOWED_FUNC_PARAMS . items (): if arg_name in type_hints and type_hints [ arg_name ] != arg_type : raise TypeError ( f \"Expected argument { arg_name !r} to be of type { arg_type !r} , but it's \" f \"typed as { type_hints [ arg_name ] !r} .\" ) if \"return\" in type_hints and type_hints [ \"return\" ] not in ( api . AgentResponse , api . Message , str , ): raise TypeError ( f \"Expected registered function to return an AgentResponse, a Message, \" f \"or str but it returns { type_hints [ 'return' ] } .\" ) # Some custom checks. if \"oauth_handler\" in params and agent . oauth_params is None : raise TypeError ( f \"Function { func_name } who accepts 'oauth_handler' as an argument cannot \" f \"be registered with agent { agent !r} who hasn't set 'oauth_params' in its \" \"constructor.\" ) return func","title":"Python Agent API"},{"location":"python-agent-api/#fixie-agent-python-api-reference","text":"This module holds objects that represent the API interface by which Agents talk to Fixie ecosystem.","title":"Fixie Agent Python API Reference"},{"location":"python-agent-api/#fixieai.agents.api.AgentQuery","text":"A standalone query sent to a Fixie agent. Source code in fixieai/agents/api.py 58 59 60 61 62 63 64 65 66 67 68 69 @pydantic_dataclasses . dataclass class AgentQuery : \"\"\"A standalone query sent to a Fixie agent.\"\"\" # The contents of the query. message : Message # This is an access token associated with the user for whom this query was # created. Agents wishing to make queries to other agents, or to other # Fixie services, should carry this token in the query so that it # can be tied back to the original user. access_token : Optional [ str ] = None","title":"AgentQuery"},{"location":"python-agent-api/#fixieai.agents.api.AgentResponse","text":"A response message from an Agent. Source code in fixieai/agents/api.py 72 73 74 75 76 77 @pydantic_dataclasses . dataclass class AgentResponse : \"\"\"A response message from an Agent.\"\"\" # The text of the response message. message : Message","title":"AgentResponse"},{"location":"python-agent-api/#fixieai.agents.api.Embed","text":"An Embed represents a binary object attached to a Message. Source code in fixieai/agents/api.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 @pydantic_dataclasses . dataclass class Embed : \"\"\"An Embed represents a binary object attached to a Message.\"\"\" # The MIME content type of the object, e.g., \"image/png\" or \"application/json\". content_type : str # A public URL where the object can be downloaded. This can be a data URI. uri : str @property def content ( self ) -> bytes : \"\"\"Retrieves the content for this Embed object.\"\"\" if self . uri . startswith ( \"data:\" ): return base64 . b64decode ( self . uri . split ( \",\" )[ 1 ]) return requests . get ( self . uri ) . content @content . setter def content ( self , content : bytes ): \"\"\"Sets the content of the Embed object as a data URI.\"\"\" self . uri = f \"data:base64, { base64 . b64encode ( content ) . decode ( 'utf-8' ) } \" @property def text ( self ) -> str : \"\"\"Retrieves the content of the Embed object as a string.\"\"\" return self . content . decode ( \"utf-8\" ) @text . setter def text ( self , text : str ): \"\"\"Sets the content of the Embed object as a string.\"\"\" self . content = text . encode ( \"utf-8\" )","title":"Embed"},{"location":"python-agent-api/#fixieai.agents.api.Embed.content","text":"Retrieves the content for this Embed object.","title":"content"},{"location":"python-agent-api/#fixieai.agents.api.Embed.text","text":"Retrieves the content of the Embed object as a string.","title":"text"},{"location":"python-agent-api/#fixieai.agents.api.Message","text":"A Message represents a single message sent to a Fixie agent. Source code in fixieai/agents/api.py 47 48 49 50 51 52 53 54 55 @pydantic_dataclasses . dataclass class Message : \"\"\"A Message represents a single message sent to a Fixie agent.\"\"\" # The text of the message. text : str # A mapping of embed keys to Embed objects. embeds : Dict [ str , Embed ] = dataclasses . field ( default_factory = dict )","title":"Message"},{"location":"python-agent-api/#fixieai.agents.code_shot.AgentMetadata","text":"Metadata for a Fixie CodeShot Agent. This will get sent to the Fixie platform upon handshake. Source code in fixieai/agents/code_shot.py 62 63 64 65 66 67 68 69 70 71 72 73 @pydantic_dataclasses . dataclass class AgentMetadata : \"\"\"Metadata for a Fixie CodeShot Agent. This will get sent to the Fixie platform upon handshake. \"\"\" base_prompt : str few_shots : List [ str ] corpora : Optional [ List [ corpora . DocumentCorpus ]] = None conversational : bool = False response_model : Optional [ LlmSettings ] = None","title":"AgentMetadata"},{"location":"python-agent-api/#fixieai.agents.code_shot.CodeShotAgent","text":"A CodeShot agent. To make a CodeShot agent, simply pass a BASE_PROMPT and FEW_SHOTS: BASE_PROMPT = \"A summary of what this agent does; how it does it; and its personality \" FEW_SHOTS = ''' Q: <Sample query that this agent supports> A: <Desired response for this query> Q: <Another sample query> A: <Desired response for this query> ''' agent = CodeShotAgent(BASE_PROMPT, FEW_SHOTS) You can have FEW_SHOTS as a single string of all your few-shots separated by 2 new lines, or as an explicit list of one few-shot per index. Your few-shots may reach out to other Agents in the fixie ecosystem by \"Ask Agent[agent_id]: \", or reach out to some python functions by \"Ask Func[func_name]: \". There are a series of default runtime Func s provided by the platform available for your agents to consume. For a full list of default runtime Func s, refer to: http://docs.fixie.ai/XXX You may also need to write your own python functions here to be consumed by your agent. To make a function accessible by an agent, you'd need to register it by @agent.register_func . Example: @agent.register_func def func_name ( query : fixieai . Message ) -> ReturnType : ... , where ReturnType is one of `str` , `fixieai.Message` , or `fixie.AgentResponse` . Note that in the above, we are using the decorator @agent.register_func to register this function with the agent instance we just created. To check out the default Func s that are provided in Fixie, see: http://docs.fixie.ai/XXX Source code in fixieai/agents/code_shot.py 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 class CodeShotAgent : \"\"\"A CodeShot agent. To make a CodeShot agent, simply pass a BASE_PROMPT and FEW_SHOTS: BASE_PROMPT = \"A summary of what this agent does; how it does it; and its personality\" FEW_SHOTS = ''' Q: <Sample query that this agent supports> A: <Desired response for this query> Q: <Another sample query> A: <Desired response for this query> ''' agent = CodeShotAgent(BASE_PROMPT, FEW_SHOTS) You can have FEW_SHOTS as a single string of all your few-shots separated by 2 new lines, or as an explicit list of one few-shot per index. Your few-shots may reach out to other Agents in the fixie ecosystem by \"Ask Agent[agent_id]: <query to pass>\", or reach out to some python functions by \"Ask Func[func_name]: <query to pass>\". There are a series of default runtime `Func`s provided by the platform available for your agents to consume. For a full list of default runtime `Func`s, refer to: http://docs.fixie.ai/XXX You may also need to write your own python functions here to be consumed by your agent. To make a function accessible by an agent, you'd need to register it by `@agent.register_func`. Example: @agent.register_func def func_name(query: fixieai.Message) -> ReturnType: ... , where ReturnType is one of `str`, `fixieai.Message`, or `fixie.AgentResponse`. Note that in the above, we are using the decorator `@agent.register_func` to register this function with the agent instance we just created. To check out the default `Func`s that are provided in Fixie, see: http://docs.fixie.ai/XXX \"\"\" def __init__ ( self , base_prompt : str , few_shots : Union [ str , List [ str ]], corpora : Optional [ List [ corpora . DocumentCorpus ]] = None , conversational : bool = False , oauth_params : Optional [ oauth . OAuthParams ] = None , llm_settings : Optional [ LlmSettings ] = None , ): if isinstance ( few_shots , str ): few_shots = _split_few_shots ( few_shots ) self . base_prompt = base_prompt self . few_shots = few_shots self . corpora = corpora self . conversational = conversational self . oauth_params = oauth_params self . llm_settings = llm_settings self . _funcs : Dict [ str , Callable ] = {} self . _jwks_client = jwt . PyJWKClient ( constants . FIXIE_JWKS_URL ) self . _allowed_agent_id = os . getenv ( \"FIXIE_ALLOWED_AGENT_ID\" ) if self . _allowed_agent_id is None : warnings . warn ( \"No allowed agent ID was specified, so your agent will accept requests intended for any agent. \" \"Ensure that the FIXIE_ALLOWED_AGENT_ID variable is set to correct this.\" ) if oauth_params is not None : # Register default Funcs. self . register_func ( _oauth ) utils . strip_prompt_lines ( self ) def serve ( self , host : str = \"0.0.0.0\" , port : int = 8181 ): \"\"\"Starts serving the current agent at `{host}:{port}` via uvicorn. Args: host: The address to start listening at. port: The port number to start listening at. \"\"\" uvicorn . run ( self . app (), host = host , port = port ) def app ( self ) -> fastapi . FastAPI : \"\"\"Returns a fastapi.FastAPI application that serves the agent.\"\"\" fast_api = fastapi . FastAPI () fast_api . include_router ( self . api_router ()) return fast_api def api_router ( self ) -> fastapi . APIRouter : \"\"\"Returns a fastapi.APIRouter object that serves the agent.\"\"\" router = fastapi . APIRouter () router . add_api_route ( \"/\" , self . _handshake , methods = [ \"GET\" ]) router . add_api_route ( \"/ {func_name} \" , self . _serve_func , methods = [ \"POST\" ]) return router def is_valid_func_name ( self , func_name : str ) -> bool : \"\"\"Indicates if the given func name is valid (either registered or built-in). Args: func_name: The func name to check \"\"\" return func_name in self . _funcs or func_name . startswith ( \"fixie_\" ) def register_func ( self , func : Optional [ Callable ] = None , * , func_name : Optional [ str ] = None ) -> Callable : \"\"\"A function decorator to register `Func`s with this agent. This decorator will not change the callable itself. Usage: agent = CodeShotAgent(base_prompt, few_shots) @agent.register_func def func(query): ... Optional Decorator Args: func_name: Optional function name to register this function by. If unset, the function name will be used. \"\"\" if func is None : # Func is not passed in. It's the decorator being created. return functools . partial ( self . register_func , func_name = func_name ) if func_name is not None : if not ACCEPTED_FUNC_NAMES . fullmatch ( func_name ): raise ValueError ( f \"Function names may only be alphanumerics, got { func_name !r} .\" ) utils . validate_registered_pyfunc ( func , self ) name = func_name or func . __name__ if name in self . _funcs : raise ValueError ( f \"Func[ { name } ] is already registered with agent.\" ) self . _funcs [ name ] = func return func def _handshake ( self , credentials : fastapi . security . HTTPAuthorizationCredentials = fastapi . Depends ( fastapi . security . HTTPBearer () ), ) -> fastapi . Response : \"\"\"Returns the agent's metadata in YAML format.\"\"\" token_claims = _VerifiedTokenClaims . from_token ( credentials . credentials , self . _jwks_client , self . _allowed_agent_id ) if token_claims is None : raise fastapi . HTTPException ( status_code = 403 , detail = \"Invalid token\" ) metadata = AgentMetadata ( self . base_prompt , self . few_shots , self . corpora , self . conversational , self . llm_settings , ) yaml_content = yaml . dump ( dataclasses . asdict ( metadata )) # Use a streaming response because prompts/fewshots can be very large. chunks = ( yaml_content [ start : start + _RESPONSE_CHUNK_SIZE ] for start in range ( 0 , len ( yaml_content ), _RESPONSE_CHUNK_SIZE ) ) return starlette . responses . StreamingResponse ( chunks , media_type = \"application/yaml\" , ) def _serve_func ( self , func_name : str , query : api . AgentQuery , credentials : fastapi . security . HTTPAuthorizationCredentials = fastapi . Depends ( fastapi . security . HTTPBearer () ), ) -> api . AgentResponse : \"\"\"Verifies the request is a valid request from Fixie, and dispatches it to the appropriate function. \"\"\" token_claims = _VerifiedTokenClaims . from_token ( credentials . credentials , self . _jwks_client , self . _allowed_agent_id ) if token_claims is None : raise fastapi . HTTPException ( status_code = 403 , detail = \"Invalid token\" ) elif ( query . access_token is not None and query . access_token != credentials . credentials ): raise fastapi . HTTPException ( status_code = 403 , detail = \"Mismatched tokens\" ) else : query . access_token = credentials . credentials try : pyfunc = self . _funcs [ func_name ] except KeyError : raise fastapi . HTTPException ( status_code = 404 , detail = f \"Func[ { func_name } ] doesn't exist\" ) kwargs = self . _get_func_kwargs ( query , token_claims , inspect . signature ( pyfunc ) . parameters . keys () ) output = pyfunc ( ** kwargs ) try : return _wrap_with_agent_response ( output ) except TypeError : raise TypeError ( f \"Func[ { func_name } ] returned unexpected output of type { type ( output ) } .\" ) def _get_func_kwargs ( self , query : api . AgentQuery , token_claims : _VerifiedTokenClaims , arg_names : Iterable [ str ], ) -> Dict [ str , Any ]: kwargs : Dict [ str , Any ] = {} for arg_name in arg_names : if arg_name == \"query\" : kwargs [ arg_name ] = query . message elif arg_name == \"user_storage\" : kwargs [ arg_name ] = user_storage . UserStorage ( query , token_claims . agent_id ) elif arg_name == \"oauth_handler\" : assert self . oauth_params , \"oauth_params is not set\" kwargs [ arg_name ] = oauth . OAuthHandler ( self . oauth_params , query , token_claims . agent_id ) else : raise ValueError ( f \"Found unknown argument { arg_name !r} .\" ) return kwargs","title":"CodeShotAgent"},{"location":"python-agent-api/#fixieai.agents.code_shot.CodeShotAgent.api_router","text":"Returns a fastapi.APIRouter object that serves the agent. Source code in fixieai/agents/code_shot.py 171 172 173 174 175 176 def api_router ( self ) -> fastapi . APIRouter : \"\"\"Returns a fastapi.APIRouter object that serves the agent.\"\"\" router = fastapi . APIRouter () router . add_api_route ( \"/\" , self . _handshake , methods = [ \"GET\" ]) router . add_api_route ( \"/ {func_name} \" , self . _serve_func , methods = [ \"POST\" ]) return router","title":"api_router()"},{"location":"python-agent-api/#fixieai.agents.code_shot.CodeShotAgent.app","text":"Returns a fastapi.FastAPI application that serves the agent. Source code in fixieai/agents/code_shot.py 165 166 167 168 169 def app ( self ) -> fastapi . FastAPI : \"\"\"Returns a fastapi.FastAPI application that serves the agent.\"\"\" fast_api = fastapi . FastAPI () fast_api . include_router ( self . api_router ()) return fast_api","title":"app()"},{"location":"python-agent-api/#fixieai.agents.code_shot.CodeShotAgent.is_valid_func_name","text":"Indicates if the given func name is valid (either registered or built-in). Parameters: Name Type Description Default func_name str The func name to check required Source code in fixieai/agents/code_shot.py 178 179 180 181 182 183 184 def is_valid_func_name ( self , func_name : str ) -> bool : \"\"\"Indicates if the given func name is valid (either registered or built-in). Args: func_name: The func name to check \"\"\" return func_name in self . _funcs or func_name . startswith ( \"fixie_\" )","title":"is_valid_func_name()"},{"location":"python-agent-api/#fixieai.agents.code_shot.CodeShotAgent.register_func","text":"A function decorator to register Func s with this agent. This decorator will not change the callable itself. Usage agent = CodeShotAgent(base_prompt, few_shots) @agent.register_func def func(query): ... Optional Decorator Args func_name: Optional function name to register this function by. If unset, the function name will be used. Source code in fixieai/agents/code_shot.py 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 def register_func ( self , func : Optional [ Callable ] = None , * , func_name : Optional [ str ] = None ) -> Callable : \"\"\"A function decorator to register `Func`s with this agent. This decorator will not change the callable itself. Usage: agent = CodeShotAgent(base_prompt, few_shots) @agent.register_func def func(query): ... Optional Decorator Args: func_name: Optional function name to register this function by. If unset, the function name will be used. \"\"\" if func is None : # Func is not passed in. It's the decorator being created. return functools . partial ( self . register_func , func_name = func_name ) if func_name is not None : if not ACCEPTED_FUNC_NAMES . fullmatch ( func_name ): raise ValueError ( f \"Function names may only be alphanumerics, got { func_name !r} .\" ) utils . validate_registered_pyfunc ( func , self ) name = func_name or func . __name__ if name in self . _funcs : raise ValueError ( f \"Func[ { name } ] is already registered with agent.\" ) self . _funcs [ name ] = func return func","title":"register_func()"},{"location":"python-agent-api/#fixieai.agents.code_shot.CodeShotAgent.serve","text":"Starts serving the current agent at {host}:{port} via uvicorn. Parameters: Name Type Description Default host str The address to start listening at. '0.0.0.0' port int The port number to start listening at. 8181 Source code in fixieai/agents/code_shot.py 156 157 158 159 160 161 162 163 def serve ( self , host : str = \"0.0.0.0\" , port : int = 8181 ): \"\"\"Starts serving the current agent at `{host}:{port}` via uvicorn. Args: host: The address to start listening at. port: The port number to start listening at. \"\"\" uvicorn . run ( self . app (), host = host , port = port )","title":"serve()"},{"location":"python-agent-api/#fixieai.agents.code_shot.LlmSettings","text":"LLM settings for agents. These settings influence how agent responses are generated by the underlying LLM. Parameters: Name Type Description Default model Optional [ str ] The name of the LLM to use. See https://docs.fixie.ai/agents/#agent-default-model-and-model-params for supported values. required temperature Optional [ float ] The sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic. The precise behavior is model-specific. required maximum_tokens Optional [ int ] The maximum number of tokens to generate in responses. One token is typically a subword. The exact token definition depends on the model. required Source code in fixieai/agents/code_shot.py 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 @pydantic_dataclasses . dataclass class LlmSettings : \"\"\"LLM settings for agents. These settings influence how agent responses are generated by the underlying LLM. Args: model Optional[str]: The name of the LLM to use. See https://docs.fixie.ai/agents/#agent-default-model-and-model-params for supported values. temperature Optional[float]: The sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic. The precise behavior is model-specific. maximum_tokens Optional[int]: The maximum number of tokens to generate in responses. One token is typically a subword. The exact token definition depends on the model. \"\"\" model : Optional [ str ] = None temperature : Optional [ float ] = None maximum_tokens : Optional [ int ] = None","title":"LlmSettings"},{"location":"python-agent-api/#fixieai.agents.oauth.OAuthHandler","text":"OAuthHandler that wraps around a (OAuthParams, query) to authenticate. This client object provides 3 main method credentials: Returns current user's OAuth access token, or None if they are not authenticated. get_authorization_url: Returns a url that the users can click to authenticate themselves. authorize: Exchanges a received access code (from auth redirect callback) for an access token. If successful, user's storage is updated. Source code in fixieai/agents/oauth.py 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 class OAuthHandler : \"\"\" OAuthHandler that wraps around a (OAuthParams, query) to authenticate. This client object provides 3 main method: * credentials: Returns current user's OAuth access token, or None if they are not authenticated. * get_authorization_url: Returns a url that the users can click to authenticate themselves. * authorize: Exchanges a received access code (from auth redirect callback) for an access token. If successful, user's storage is updated. \"\"\" # OAuth keys reserved in UserStorage OAUTH_STATE_KEY = \"_oauth_state\" OAUTH_TOKEN_KEY = \"_oauth_token\" def __init__ ( self , oauth_params : OAuthParams , query : api . AgentQuery , agent_id : str , ): self . _storage = user_storage . UserStorage ( query , agent_id ) self . _oauth_params = oauth_params self . _agent_id = agent_id def get_authorization_url ( self ) -> str : \"\"\"Returns a URL to launch the authorization flow.\"\"\" auth_state = f \" { self . _agent_id } : { secrets . token_urlsafe () } \" data = { \"response_type\" : \"code\" , \"access_type\" : \"offline\" , \"client_id\" : self . _oauth_params . client_id , \"scope\" : \" \" . join ( self . _oauth_params . scopes ), \"state\" : auth_state , \"redirect_uri\" : constants . FIXIE_OAUTH_REDIRECT_URL , } url = self . _oauth_params . auth_uri + \"?\" + parse . urlencode ( data ) # Store auth_state in UserStorage for validation later. self . _storage [ self . OAUTH_STATE_KEY ] = auth_state return url def user_token ( self ) -> Optional [ str ]: \"\"\"Returns current user's OAuth credentials, or None if not authorized.\"\"\" try : creds_json = self . _storage [ self . OAUTH_TOKEN_KEY ] except KeyError : return None if not isinstance ( creds_json , str ): logging . warning ( f \"Value at user_storage[ { self . OAUTH_TOKEN_KEY !r} ] is \" f \"not an OAuthCredentials json: { creds_json !r} \" ) del self . _storage [ self . OAUTH_TOKEN_KEY ] return None try : creds = _OAuthCredentials . from_json ( creds_json ) except ( TypeError , LookupError , ValueError ): logging . warning ( f \"Value at user_storage[ { self . OAUTH_TOKEN_KEY !r} ] is \" f \"not a valid _OAuthCredentials json: { creds_json !r} \" ) del self . _storage [ self . OAUTH_TOKEN_KEY ] return None if creds . expired : logging . debug ( f \"Credentials expired at { creds . expiry } \" ) if not creds . refresh_token : logging . warning ( \"No refresh token available\" ) return None logging . debug ( \"Refreshing credentials...\" ) creds . refresh ( self . _oauth_params ) self . _save_credentials ( creds ) # Save refreshed token to UserStorage return creds . access_token def authorize ( self , state : str , code : str ): \"\"\"Authorize the received access `code` against the client secret. If successful, the credentials will be saved in user storage. \"\"\" expected_state = self . _storage [ self . OAUTH_STATE_KEY ] if state != expected_state : logging . warning ( f \"Unknown state token, expected: { expected_state !r} actual: { state !r} \" ) raise ValueError ( f \"Unknown state token\" ) data = { \"grant_type\" : \"authorization_code\" , \"client_id\" : self . _oauth_params . client_id , \"client_secret\" : self . _oauth_params . client_secret , \"code\" : code , \"redirect_uri\" : constants . FIXIE_OAUTH_REDIRECT_URL , } response = _send_authorize_request ( self . _oauth_params . token_uri , data ) logging . debug ( f \"OAuth auth request succeeded, lifetime= { response . expires_in } \" f \"refreshable= { response . refresh_token is not None } \" ) credentials = _OAuthCredentials ( response . access_token , _get_expiry ( response . expires_in ), response . refresh_token , ) self . _save_credentials ( credentials ) def _save_credentials ( self , credentials : \"_OAuthCredentials\" ): self . _storage [ self . OAUTH_TOKEN_KEY ] = credentials . to_json ()","title":"OAuthHandler"},{"location":"python-agent-api/#fixieai.agents.oauth.OAuthHandler.authorize","text":"Authorize the received access code against the client secret. If successful, the credentials will be saved in user storage. Source code in fixieai/agents/oauth.py 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 def authorize ( self , state : str , code : str ): \"\"\"Authorize the received access `code` against the client secret. If successful, the credentials will be saved in user storage. \"\"\" expected_state = self . _storage [ self . OAUTH_STATE_KEY ] if state != expected_state : logging . warning ( f \"Unknown state token, expected: { expected_state !r} actual: { state !r} \" ) raise ValueError ( f \"Unknown state token\" ) data = { \"grant_type\" : \"authorization_code\" , \"client_id\" : self . _oauth_params . client_id , \"client_secret\" : self . _oauth_params . client_secret , \"code\" : code , \"redirect_uri\" : constants . FIXIE_OAUTH_REDIRECT_URL , } response = _send_authorize_request ( self . _oauth_params . token_uri , data ) logging . debug ( f \"OAuth auth request succeeded, lifetime= { response . expires_in } \" f \"refreshable= { response . refresh_token is not None } \" ) credentials = _OAuthCredentials ( response . access_token , _get_expiry ( response . expires_in ), response . refresh_token , ) self . _save_credentials ( credentials )","title":"authorize()"},{"location":"python-agent-api/#fixieai.agents.oauth.OAuthHandler.get_authorization_url","text":"Returns a URL to launch the authorization flow. Source code in fixieai/agents/oauth.py 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 def get_authorization_url ( self ) -> str : \"\"\"Returns a URL to launch the authorization flow.\"\"\" auth_state = f \" { self . _agent_id } : { secrets . token_urlsafe () } \" data = { \"response_type\" : \"code\" , \"access_type\" : \"offline\" , \"client_id\" : self . _oauth_params . client_id , \"scope\" : \" \" . join ( self . _oauth_params . scopes ), \"state\" : auth_state , \"redirect_uri\" : constants . FIXIE_OAUTH_REDIRECT_URL , } url = self . _oauth_params . auth_uri + \"?\" + parse . urlencode ( data ) # Store auth_state in UserStorage for validation later. self . _storage [ self . OAUTH_STATE_KEY ] = auth_state return url","title":"get_authorization_url()"},{"location":"python-agent-api/#fixieai.agents.oauth.OAuthHandler.user_token","text":"Returns current user's OAuth credentials, or None if not authorized. Source code in fixieai/agents/oauth.py 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 def user_token ( self ) -> Optional [ str ]: \"\"\"Returns current user's OAuth credentials, or None if not authorized.\"\"\" try : creds_json = self . _storage [ self . OAUTH_TOKEN_KEY ] except KeyError : return None if not isinstance ( creds_json , str ): logging . warning ( f \"Value at user_storage[ { self . OAUTH_TOKEN_KEY !r} ] is \" f \"not an OAuthCredentials json: { creds_json !r} \" ) del self . _storage [ self . OAUTH_TOKEN_KEY ] return None try : creds = _OAuthCredentials . from_json ( creds_json ) except ( TypeError , LookupError , ValueError ): logging . warning ( f \"Value at user_storage[ { self . OAUTH_TOKEN_KEY !r} ] is \" f \"not a valid _OAuthCredentials json: { creds_json !r} \" ) del self . _storage [ self . OAUTH_TOKEN_KEY ] return None if creds . expired : logging . debug ( f \"Credentials expired at { creds . expiry } \" ) if not creds . refresh_token : logging . warning ( \"No refresh token available\" ) return None logging . debug ( \"Refreshing credentials...\" ) creds . refresh ( self . _oauth_params ) self . _save_credentials ( creds ) # Save refreshed token to UserStorage return creds . access_token","title":"user_token()"},{"location":"python-agent-api/#fixieai.agents.oauth.OAuthParams","text":"Encapsulates OAuth parameters, including secret, auth uri, and the scope. Agents who want to use OAuth flow, should declare their secrets via this object. Source code in fixieai/agents/oauth.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 @dataclasses . dataclass class OAuthParams : \"\"\"Encapsulates OAuth parameters, including secret, auth uri, and the scope. Agents who want to use OAuth flow, should declare their secrets via this object. \"\"\" client_id : str client_secret : str auth_uri : str token_uri : str scopes : List [ str ] @classmethod def from_client_secrets_file ( cls , secrets_path : str , scopes : List [ str ] ) -> \"OAuthParams\" : \"\"\"Initializes OAuth from a secrets file, e.g., as obtained from the Google Cloud Console. Args: secrets_path: Path to a json file holding secret values. scopes: A list of scopes that access needs to be requested for. \"\"\" with open ( secrets_path , \"r\" ) as file : data = json . load ( file ) secrets = data [ \"web\" ] or data [ \"installed\" ] return cls ( secrets [ \"client_id\" ], secrets [ \"client_secret\" ], secrets [ \"auth_uri\" ], secrets [ \"token_uri\" ], scopes , )","title":"OAuthParams"},{"location":"python-agent-api/#fixieai.agents.oauth.OAuthParams.from_client_secrets_file","text":"Initializes OAuth from a secrets file, e.g., as obtained from the Google Cloud Console. Parameters: Name Type Description Default secrets_path str Path to a json file holding secret values. required scopes List [ str ] A list of scopes that access needs to be requested for. required Source code in fixieai/agents/oauth.py 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 @classmethod def from_client_secrets_file ( cls , secrets_path : str , scopes : List [ str ] ) -> \"OAuthParams\" : \"\"\"Initializes OAuth from a secrets file, e.g., as obtained from the Google Cloud Console. Args: secrets_path: Path to a json file holding secret values. scopes: A list of scopes that access needs to be requested for. \"\"\" with open ( secrets_path , \"r\" ) as file : data = json . load ( file ) secrets = data [ \"web\" ] or data [ \"installed\" ] return cls ( secrets [ \"client_id\" ], secrets [ \"client_secret\" ], secrets [ \"auth_uri\" ], secrets [ \"token_uri\" ], scopes , )","title":"from_client_secrets_file()"},{"location":"python-agent-api/#fixieai.agents.user_storage.UserStorage","text":"Bases: MutableMapping [ str , UserStorageType ] UserStorage provides a dict-like interface to a user-specific storage. Usage: from fixieai import AgentQuery, Message query = AgentQuery( ... Message(\"incoming query\"), ... access_token=\"fake-access-token\" ... ) storage = UserStorage(query, \"fake-agent\") storage[\"key\"] = \"value\" storage[\"complex-key\"] = {\"key1\": {\"key2\": [12, False, None, b\"binary\"]}} assert len(storage) == 2 assert storage \"complex-key\" \"key2\" == b\"binary\" Source code in fixieai/agents/user_storage.py 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 class UserStorage ( MutableMapping [ str , UserStorageType ]): \"\"\"UserStorage provides a dict-like interface to a user-specific storage. Usage: >>> from fixieai import AgentQuery, Message >>> query = AgentQuery( ... Message(\"incoming query\"), ... access_token=\"fake-access-token\" ... ) >>> storage = UserStorage(query, \"fake-agent\") >>> storage[\"key\"] = \"value\" >>> storage[\"complex-key\"] = {\"key1\": {\"key2\": [12, False, None, b\"binary\"]}} >>> assert len(storage) == 2 >>> assert storage[\"complex-key\"][\"key1\"][\"key2\"][-1] == b\"binary\" \"\"\" def __init__ ( self , query : \"AgentQuery\" , agent_id : str , userstorage_url : str = constants . FIXIE_USER_STORAGE_URL , ): # TODO(hessam): Remove agent_id from args once access_token includes agent_id # as well. self . _agent_id = agent_id self . _userstorage_url = userstorage_url self . _session = requests . Session () self . _session . headers . update ({ \"Authorization\" : f \"Bearer { query . access_token } \" }) def __setitem__ ( self , key : str , value : UserStorageType ): url = f \" { self . _userstorage_url } / { self . _agent_id } / { key } \" response = self . _session . post ( url , json = { \"data\" : to_json ( value )}) response . raise_for_status () def __getitem__ ( self , key : str ) -> UserStorageType : url = f \" { self . _userstorage_url } / { self . _agent_id } / { key } \" try : response = self . _session . get ( url ) response . raise_for_status () return from_json ( response . json ()[ \"data\" ]) except requests . exceptions . HTTPError as e : raise KeyError ( f \"Key { key } not found\" ) from e def __contains__ ( self , key : object ) -> bool : url = f \" { self . _userstorage_url } / { self . _agent_id } / { key } \" try : response = self . _session . head ( url ) response . raise_for_status () return True except requests . exceptions . HTTPError as e : return False def __delitem__ ( self , key : str ): url = f \" { self . _userstorage_url } / { self . _agent_id } / { key } \" try : response = self . _session . delete ( url ) response . raise_for_status () except requests . exceptions . HTTPError as e : raise KeyError ( f \"Key { key } not found\" ) from e def _get_all_keys ( self ): url = f \" { self . _userstorage_url } / { self . _agent_id } \" response = self . _session . get ( url ) response . raise_for_status () return [ value [ \"key\" ] for value in response . json ()] def __iter__ ( self ): return iter ( self . _get_all_keys ()) def __len__ ( self ): return len ( self . _get_all_keys ())","title":"UserStorage"},{"location":"python-agent-api/#fixieai.agents.user_storage.from_json","text":"Deserializes a UserStorageType from a JSON string. Source code in fixieai/agents/user_storage.py 101 102 103 def from_json ( json_dump : str ) -> UserStorageType : \"\"\"Deserializes a UserStorageType from a JSON string.\"\"\" return from_json_type ( json . loads ( json_dump ))","title":"from_json()"},{"location":"python-agent-api/#fixieai.agents.user_storage.from_json_type","text":"Decodes a JsonType to UserStorageType. Source code in fixieai/agents/user_storage.py 118 119 120 121 122 123 124 125 126 127 def from_json_type ( obj : JsonType ) -> UserStorageType : \"\"\"Decodes a JsonType to UserStorageType.\"\"\" if _is_bytes_encoded_json_dict ( obj ): return base64 . b64decode ( obj [ \"data\" ]) # type: ignore elif isinstance ( obj , list ): return [ from_json_type ( item ) for item in obj ] elif isinstance ( obj , dict ): return { key : from_json_type ( value ) for key , value in obj . items ()} else : return obj","title":"from_json_type()"},{"location":"python-agent-api/#fixieai.agents.user_storage.to_json","text":"Serialize a UserStorageType to a JSON string. Source code in fixieai/agents/user_storage.py 96 97 98 def to_json ( obj : UserStorageType ) -> str : \"\"\"Serialize a UserStorageType to a JSON string.\"\"\" return json . dumps ( to_json_type ( obj ))","title":"to_json()"},{"location":"python-agent-api/#fixieai.agents.user_storage.to_json_type","text":"Encodes a UserStorageType to JsonType. Source code in fixieai/agents/user_storage.py 106 107 108 109 110 111 112 113 114 115 def to_json_type ( obj : UserStorageType ) -> JsonType : \"\"\"Encodes a UserStorageType to JsonType.\"\"\" if isinstance ( obj , bytes ): return { \"type\" : \"_bytes_ascii\" , \"data\" : base64 . b64encode ( obj ) . decode ( \"ASCII\" )} elif isinstance ( obj , list ): return [ to_json_type ( item ) for item in obj ] elif isinstance ( obj , dict ): return { key : to_json_type ( value ) for key , value in obj . items ()} else : return obj","title":"to_json_type()"},{"location":"python-agent-api/#fixieai.agents.utils.FewshotLinePattern","text":"Bases: enum . Enum Source code in fixieai/agents/utils.py 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 class FewshotLinePattern ( enum . Enum ): QUERY = re . compile ( r \"^Q:\" ) AGENT_SAYS = re . compile ( r \"^Agent\\[(?P<agent_id>\\w+)] says:\" ) FUNC_SAYS = re . compile ( r \"^Func\\[(?P<func_name>\\w+)] says:\" ) ASK_AGENT = re . compile ( r \"^Ask Agent\\[(?P<agent_id>\\w+)]:\" ) ASK_FUNC = re . compile ( r \"^Ask Func\\[(?P<func_name>\\w+)]:\" ) RESPONSE = re . compile ( r \"^A:\" ) NO_PATTERN : None = None @classmethod def match ( cls , line : str ) -> Optional [ re . Match [ str ]]: \"\"\"Returns a match from a FewshotLinePattern for a given line, or None if nothing matched.\"\"\" if \" \\n \" in line : raise ValueError ( \"Cannot get the pattern for a multi-line text. Patterns must be \" \"extracted one line at a time.\" ) matches = [ match for prompt_pattern in cls if prompt_pattern is not cls . NO_PATTERN and ( match := prompt_pattern . value . match ( line )) ] if len ( matches ) > 1 : raise RuntimeError ( f \"More than one pattern ( { list ( FewshotLinePattern ( match . re ) for match in matches ) } ) matched the line { line !r} .\" ) elif len ( matches ) == 0 : return None match = matches [ 0 ] if match . re is cls . QUERY . value : if match . end () == len ( line ): raise ValueError ( \"A 'Q:' line cannot end without a query.\" ) assert isinstance ( match , re . Match ) return match","title":"FewshotLinePattern"},{"location":"python-agent-api/#fixieai.agents.utils.FewshotLinePattern.match","text":"Returns a match from a FewshotLinePattern for a given line, or None if nothing matched. Source code in fixieai/agents/utils.py 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 @classmethod def match ( cls , line : str ) -> Optional [ re . Match [ str ]]: \"\"\"Returns a match from a FewshotLinePattern for a given line, or None if nothing matched.\"\"\" if \" \\n \" in line : raise ValueError ( \"Cannot get the pattern for a multi-line text. Patterns must be \" \"extracted one line at a time.\" ) matches = [ match for prompt_pattern in cls if prompt_pattern is not cls . NO_PATTERN and ( match := prompt_pattern . value . match ( line )) ] if len ( matches ) > 1 : raise RuntimeError ( f \"More than one pattern ( { list ( FewshotLinePattern ( match . re ) for match in matches ) } ) matched the line { line !r} .\" ) elif len ( matches ) == 0 : return None match = matches [ 0 ] if match . re is cls . QUERY . value : if match . end () == len ( line ): raise ValueError ( \"A 'Q:' line cannot end without a query.\" ) assert isinstance ( match , re . Match ) return match","title":"match()"},{"location":"python-agent-api/#fixieai.agents.utils.strip_prompt_lines","text":"Strips all prompt lines. Source code in fixieai/agents/utils.py 20 21 22 23 24 def strip_prompt_lines ( agent : code_shot . CodeShotAgent ): \"\"\"Strips all prompt lines.\"\"\" agent . base_prompt = _strip_all_lines ( agent . base_prompt ) for i , fewshot in enumerate ( agent . few_shots ): agent . few_shots [ i ] = _strip_all_lines ( fewshot )","title":"strip_prompt_lines()"},{"location":"python-agent-api/#fixieai.agents.utils.validate_code_shot_agent","text":"A client-side validation of few_shots and agent. Source code in fixieai/agents/utils.py 27 28 29 30 31 32 33 def validate_code_shot_agent ( agent : code_shot . CodeShotAgent ): \"\"\"A client-side validation of few_shots and agent.\"\"\" _validate_base_prompt ( agent . base_prompt ) for fewshot in agent . few_shots : _validate_few_shot_prompt ( fewshot , agent . conversational , agent . is_valid_func_name )","title":"validate_code_shot_agent()"},{"location":"python-agent-api/#fixieai.agents.utils.validate_registered_pyfunc","text":"Validates func 's signature to be a valid CodeShot Func. Parameters: Name Type Description Default func Callable The function to be validated. required agent code_shot . CodeShotAgent The CodeShotAgent that this func is going to be registered for. required Source code in fixieai/agents/utils.py 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 def validate_registered_pyfunc ( func : Callable , agent : code_shot . CodeShotAgent ): \"\"\"Validates `func`'s signature to be a valid CodeShot Func. Args: func: The function to be validated. agent: The CodeShotAgent that this func is going to be registered for. \"\"\" # Delayed import to avoid circular dependency from fixieai.agents import api from fixieai.agents import oauth from fixieai.agents import user_storage ALLOWED_FUNC_PARAMS = { \"query\" : api . Message , \"user_storage\" : user_storage . UserStorage , \"oauth_handler\" : oauth . OAuthHandler , } # Validate that func is a function type. if not inspect . isfunction ( func ): raise TypeError ( f \"Registered function { func !r} is not a function, but a { type ( func ) !r} .\" ) signature = inspect . signature ( func ) func_name = func . __name__ params = signature . parameters # Validate that there are not var args (*args or **kwargs). if any ( param . kind in ( param . VAR_KEYWORD , param . VAR_POSITIONAL ) for param in params . values () ): raise TypeError ( f \"Registered function { func_name } cannot accept variable args: { params !r} .\" ) # Validate that all argument names are known. unknown_params = set ( params . keys ()) - set ( ALLOWED_FUNC_PARAMS . keys ()) if unknown_params : raise TypeError ( f \"Registered function { func_name } gets unknown arguments { unknown_params } . \" f \"List of allowed Func arguments are { list ( ALLOWED_FUNC_PARAMS . keys ()) } .\" ) # Check the type annotations match what's expected, if func is type annotated. type_hints = get_type_hints ( func ) for arg_name , arg_type in ALLOWED_FUNC_PARAMS . items (): if arg_name in type_hints and type_hints [ arg_name ] != arg_type : raise TypeError ( f \"Expected argument { arg_name !r} to be of type { arg_type !r} , but it's \" f \"typed as { type_hints [ arg_name ] !r} .\" ) if \"return\" in type_hints and type_hints [ \"return\" ] not in ( api . AgentResponse , api . Message , str , ): raise TypeError ( f \"Expected registered function to return an AgentResponse, a Message, \" f \"or str but it returns { type_hints [ 'return' ] } .\" ) # Some custom checks. if \"oauth_handler\" in params and agent . oauth_params is None : raise TypeError ( f \"Function { func_name } who accepts 'oauth_handler' as an argument cannot \" f \"be registered with agent { agent !r} who hasn't set 'oauth_params' in its \" \"constructor.\" ) return func","title":"validate_registered_pyfunc()"},{"location":"python-client-api/","text":"Fixie Client Python API Reference FixieClient FixieClient is a client to the Fixie system. Parameters: Name Type Description Default api_key Optional [ str ] The API key for the Fixie API server. If not provided, the FIXIE_API_KEY environment variable will be used. If that is not set, the authenticated user API key will be used, or a ValueError will be raised if the user is not authenticated. None Source code in fixieai/client/client.py 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 class FixieClient : \"\"\"FixieClient is a client to the Fixie system. Args: api_key: The API key for the Fixie API server. If not provided, the FIXIE_API_KEY environment variable will be used. If that is not set, the authenticated user API key will be used, or a ValueError will be raised if the user is not authenticated. \"\"\" def __init__ ( self , api_key : Optional [ str ] = None , ): self . _api_key = api_key or constants . fixie_api_key () logging . info ( f \"Using Fixie API URL: { constants . FIXIE_API_URL } \" ) self . _request_headers = { \"Authorization\" : f \"Bearer { self . _api_key } \" } transport = RequestsHTTPTransport ( url = constants . FIXIE_GRAPHQL_URL , headers = self . _request_headers , ) self . _gqlclient = Client ( transport = transport , fetch_schema_from_transport = False ) @property def gqlclient ( self ) -> Client : \"\"\"Return the underlying GraphQL client used by this FixieClient.\"\"\" return self . _gqlclient @property def url ( self ) -> str : \"\"\"Return the URL of the Fixie API server.\"\"\" return constants . FIXIE_API_URL def clone ( self ) -> \"FixieClient\" : \"\"\"Return a new FixieClient instance with the same configuration.\"\"\" return FixieClient ( api_key = self . _api_key ) def get_agents ( self ) -> Dict [ str , Dict [ str , str ]]: \"\"\"Return metadata about all running Fixie Agents. The keys of the returned dictionary are the Agent handles, and the values are dictionaries containing metadata about each Agent.\"\"\" query = gql ( \"\"\" query getAgents { allAgents { agentId name description moreInfoUrl } } \"\"\" ) result = self . _gqlclient . execute ( query ) assert \"allAgents\" in result and isinstance ( result [ \"allAgents\" ], list ) agents = result [ \"allAgents\" ] return { agent [ \"agentId\" ]: agent for agent in agents } def get_agent ( self , agent_id : str ) -> Agent : \"\"\"Return an existing Agent object.\"\"\" return Agent ( self , agent_id ) def create_agent ( self , handle : str , name : str , description : str , query_url : Optional [ str ] = None , func_url : Optional [ str ] = None , more_info_url : Optional [ str ] = None , published : Optional [ bool ] = None , ) -> Agent : \"\"\"Create a new Agent. Args: handle: The handle for the new Agent. This must be unique across all Agents owned by this user. name: The name of the new Agent. description: A description of the new Agent. query_url: The URL of the new Agent's query endpoint. func_url: The URL of the new Agent's func endpoint. more_info_url: A URL with more information about the new Agent. published: Whether the new Agent should be published. \"\"\" agent = Agent ( self , f \" { self . get_current_username () } / { handle } \" ) agent . create_agent ( name , description , query_url , func_url , more_info_url , published ) return agent def get_sessions ( self ) -> List [ str ]: \"\"\"Return a list of all session IDs.\"\"\" query = gql ( \"\"\" query getSessions { allSessions { handle } } \"\"\" ) result = self . _gqlclient . execute ( query ) assert \"allSessions\" in result and isinstance ( result [ \"allSessions\" ], list ) sessions = result [ \"allSessions\" ] return [ session [ \"handle\" ] for session in sessions ] def create_session ( self , frontend_agent_id : Optional [ str ] = None ) -> Session : \"\"\"Create a new Session.\"\"\" return Session ( self , frontend_agent_id = frontend_agent_id ) def get_session ( self , session_id : str ) -> Session : \"\"\"Return an existing Session object.\"\"\" return Session ( self , session_id ) def get_current_username ( self ) -> str : \"\"\"Returns the username of the current user.\"\"\" query = gql ( \"\"\" query getUsername { user { username } } \"\"\" ) result = self . _gqlclient . execute ( query ) assert \"user\" in result and isinstance ( result [ \"user\" ], dict ) user = result [ \"user\" ] assert \"username\" in user and isinstance ( user [ \"username\" ], str ) return user [ \"username\" ] def refresh_agent ( self , agent_handle : str ): \"\"\"Indicates that an agent's prompts should be refreshed.\"\"\" username = self . get_current_username () requests . post ( f \" { constants . FIXIE_REFRESH_URL } / { username } / { agent_handle } \" , headers = self . _request_headers , ) . raise_for_status () def deploy_agent ( self , handle : str , gzip_tarfile : BinaryIO , ): \"\"\"Deploys an agent implementation. Args: handle: The handle of the Agent to deploy. Must be owned by the current user. gzip_tarfile: A file-like of a gzip-compressed tarfile containing the files to deploy. \"\"\" username = self . get_current_username () requests . post ( f \" { constants . FIXIE_DEPLOYMENT_URL } / { username } / { handle } \" , headers = self . _request_headers , files = { \"agent.tar.gz\" : ( \"agent.tar.gz\" , gzip_tarfile , \"application/gzip\" )}, ) . raise_for_status () gqlclient : Client property Return the underlying GraphQL client used by this FixieClient. url : str property Return the URL of the Fixie API server. clone () Return a new FixieClient instance with the same configuration. Source code in fixieai/client/client.py 89 90 91 def clone ( self ) -> \"FixieClient\" : \"\"\"Return a new FixieClient instance with the same configuration.\"\"\" return FixieClient ( api_key = self . _api_key ) create_agent ( handle , name , description , query_url = None , func_url = None , more_info_url = None , published = None ) Create a new Agent. Parameters: Name Type Description Default handle str The handle for the new Agent. This must be unique across all Agents owned by this user. required name str The name of the new Agent. required description str A description of the new Agent. required query_url Optional [ str ] The URL of the new Agent's query endpoint. None func_url Optional [ str ] The URL of the new Agent's func endpoint. None more_info_url Optional [ str ] A URL with more information about the new Agent. None published Optional [ bool ] Whether the new Agent should be published. None Source code in fixieai/client/client.py 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 def create_agent ( self , handle : str , name : str , description : str , query_url : Optional [ str ] = None , func_url : Optional [ str ] = None , more_info_url : Optional [ str ] = None , published : Optional [ bool ] = None , ) -> Agent : \"\"\"Create a new Agent. Args: handle: The handle for the new Agent. This must be unique across all Agents owned by this user. name: The name of the new Agent. description: A description of the new Agent. query_url: The URL of the new Agent's query endpoint. func_url: The URL of the new Agent's func endpoint. more_info_url: A URL with more information about the new Agent. published: Whether the new Agent should be published. \"\"\" agent = Agent ( self , f \" { self . get_current_username () } / { handle } \" ) agent . create_agent ( name , description , query_url , func_url , more_info_url , published ) return agent create_session ( frontend_agent_id = None ) Create a new Session. Source code in fixieai/client/client.py 164 165 166 def create_session ( self , frontend_agent_id : Optional [ str ] = None ) -> Session : \"\"\"Create a new Session.\"\"\" return Session ( self , frontend_agent_id = frontend_agent_id ) deploy_agent ( handle , gzip_tarfile ) Deploys an agent implementation. Parameters: Name Type Description Default handle str The handle of the Agent to deploy. Must be owned by the current user. required gzip_tarfile BinaryIO A file-like of a gzip-compressed tarfile containing the files to deploy. required Source code in fixieai/client/client.py 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 def deploy_agent ( self , handle : str , gzip_tarfile : BinaryIO , ): \"\"\"Deploys an agent implementation. Args: handle: The handle of the Agent to deploy. Must be owned by the current user. gzip_tarfile: A file-like of a gzip-compressed tarfile containing the files to deploy. \"\"\" username = self . get_current_username () requests . post ( f \" { constants . FIXIE_DEPLOYMENT_URL } / { username } / { handle } \" , headers = self . _request_headers , files = { \"agent.tar.gz\" : ( \"agent.tar.gz\" , gzip_tarfile , \"application/gzip\" )}, ) . raise_for_status () get_agent ( agent_id ) Return an existing Agent object. Source code in fixieai/client/client.py 115 116 117 def get_agent ( self , agent_id : str ) -> Agent : \"\"\"Return an existing Agent object.\"\"\" return Agent ( self , agent_id ) get_agents () Return metadata about all running Fixie Agents. The keys of the returned dictionary are the Agent handles, and the values are dictionaries containing metadata about each Agent. Source code in fixieai/client/client.py 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 def get_agents ( self ) -> Dict [ str , Dict [ str , str ]]: \"\"\"Return metadata about all running Fixie Agents. The keys of the returned dictionary are the Agent handles, and the values are dictionaries containing metadata about each Agent.\"\"\" query = gql ( \"\"\" query getAgents { allAgents { agentId name description moreInfoUrl } } \"\"\" ) result = self . _gqlclient . execute ( query ) assert \"allAgents\" in result and isinstance ( result [ \"allAgents\" ], list ) agents = result [ \"allAgents\" ] return { agent [ \"agentId\" ]: agent for agent in agents } get_current_username () Returns the username of the current user. Source code in fixieai/client/client.py 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 def get_current_username ( self ) -> str : \"\"\"Returns the username of the current user.\"\"\" query = gql ( \"\"\" query getUsername { user { username } } \"\"\" ) result = self . _gqlclient . execute ( query ) assert \"user\" in result and isinstance ( result [ \"user\" ], dict ) user = result [ \"user\" ] assert \"username\" in user and isinstance ( user [ \"username\" ], str ) return user [ \"username\" ] get_session ( session_id ) Return an existing Session object. Source code in fixieai/client/client.py 168 169 170 def get_session ( self , session_id : str ) -> Session : \"\"\"Return an existing Session object.\"\"\" return Session ( self , session_id ) get_sessions () Return a list of all session IDs. Source code in fixieai/client/client.py 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 def get_sessions ( self ) -> List [ str ]: \"\"\"Return a list of all session IDs.\"\"\" query = gql ( \"\"\" query getSessions { allSessions { handle } } \"\"\" ) result = self . _gqlclient . execute ( query ) assert \"allSessions\" in result and isinstance ( result [ \"allSessions\" ], list ) sessions = result [ \"allSessions\" ] return [ session [ \"handle\" ] for session in sessions ] refresh_agent ( agent_handle ) Indicates that an agent's prompts should be refreshed. Source code in fixieai/client/client.py 189 190 191 192 193 194 195 def refresh_agent ( self , agent_handle : str ): \"\"\"Indicates that an agent's prompts should be refreshed.\"\"\" username = self . get_current_username () requests . post ( f \" { constants . FIXIE_REFRESH_URL } / { username } / { agent_handle } \" , headers = self . _request_headers , ) . raise_for_status () get_agents () Return metadata about all Fixie Agents. The keys of the returned dictionary are Agent IDs, and the values are dictionaries containing metadata about each Agent. Source code in fixieai/client/client.py 39 40 41 42 43 def get_agents () -> Dict [ str , Dict [ str , str ]]: \"\"\"Return metadata about all Fixie Agents. The keys of the returned dictionary are Agent IDs, and the values are dictionaries containing metadata about each Agent.\"\"\" return get_client () . get_agents () get_client () Return the global FixieClient instance. Source code in fixieai/client/client.py 21 22 23 24 25 26 27 def get_client () -> FixieClient : \"\"\"Return the global FixieClient instance.\"\"\" global _CLIENT if not _CLIENT : _CLIENT = FixieClient () assert _CLIENT is not None return _CLIENT get_embeds () Return a list of Embeds. Source code in fixieai/client/client.py 51 52 53 def get_embeds () -> List [ Dict [ str , Any ]]: \"\"\"Return a list of Embeds.\"\"\" return get_session () . get_embeds () get_session () Return the global Fixie Session instance. Source code in fixieai/client/client.py 30 31 32 33 34 35 36 def get_session () -> Session : \"\"\"Return the global Fixie Session instance.\"\"\" global _SESSION if not _SESSION : _SESSION = Session ( get_client ()) assert _SESSION is not None return _SESSION query ( text ) Run a query. Source code in fixieai/client/client.py 46 47 48 def query ( text : str ) -> str : \"\"\"Run a query.\"\"\" return get_session () . query ( text ) Session Represents a single session with the Fixie system. Parameters: Name Type Description Default client FixieClient The FixieClient instance to use. required session_id Optional [ str ] The ID of the session to use. If not provided, a new session will be created. None Source code in fixieai/client/session.py 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 class Session : \"\"\"Represents a single session with the Fixie system. Args: client: The FixieClient instance to use. session_id: The ID of the session to use. If not provided, a new session will be created. \"\"\" def __init__ ( self , client : FixieClient , session_id : Optional [ str ] = None , frontend_agent_id : Optional [ str ] = None , ): self . _client = client self . _gqlclient = self . _client . gqlclient self . _session_id = session_id if session_id : # Test that the session exists. _ = self . get_metadata () assert ( frontend_agent_id is None ), \"Cannot specify frontend_agent_id when using an existing session\" else : self . _session_id = self . _create_session ( frontend_agent_id ) self . _frontend_agent_id : Optional [ str ] = None self . _last_message_timestamp : Optional [ datetime . datetime ] = None @property def session_id ( self ) -> Optional [ str ]: \"\"\"Return the session ID used by this Fixie client.\"\"\" return self . _session_id @property def session_url ( self ) -> str : \"\"\"Return the URL of the Fixie session.\"\"\" return f \" { self . _client . url } /sessions/ { self . session_id } \" @property def frontend_agent_id ( self ) -> Optional [ str ]: \"\"\"Return the frontend agent ID used by this Fixie client.\"\"\" return self . _frontend_agent_id def clone ( self ) -> \"Session\" : \"\"\"Return a new Session instance with the same configuration.\"\"\" return Session ( self . _client . clone (), session_id = self . _session_id ) def _create_session ( self , frontend_agent_id : Optional [ str ] = None ) -> str : \"\"\"Create a new session.\"\"\" assert self . _session_id is None query = gql ( \"\"\" mutation CreateSession($frontendAgentId: String) { createSession(sessionData: {frontendAgentId: $frontendAgentId}) { session { handle frontendAgentId } } } \"\"\" ) result = self . _gqlclient . execute ( query , variable_values = { \"frontendAgentId\" : frontend_agent_id } ) if \"createSession\" not in result or result [ \"createSession\" ] is None : raise ValueError ( f \"Failed to create Session\" ) assert isinstance ( result [ \"createSession\" ], dict ) assert isinstance ( result [ \"createSession\" ][ \"session\" ], dict ) self . _frontend_agent_id = result [ \"createSession\" ][ \"session\" ][ \"frontendAgentId\" ] assert isinstance ( result [ \"createSession\" ][ \"session\" ][ \"handle\" ], str ) return result [ \"createSession\" ][ \"session\" ][ \"handle\" ] def get_metadata ( self ) -> Dict [ str , Any ]: \"\"\"Return metadata about this session.\"\"\" query = gql ( \"\"\" query getSession($session_id: String!) { sessionByHandle(handle: $session_id) { handle name description frontendAgentId } } \"\"\" ) result = self . _gqlclient . execute ( query , variable_values = { \"session_id\" : self . _session_id } ) assert \"sessionByHandle\" in result and isinstance ( result [ \"sessionByHandle\" ], dict ) self . _frontend_agent_id = result [ \"sessionByHandle\" ][ \"frontendAgentId\" ] return result [ \"sessionByHandle\" ] def delete_session ( self ) -> None : \"\"\"Delete the current session.\"\"\" query = gql ( \"\"\" mutation DeleteSession($handle: String!) { deleteSession(handle: $handle) { session { handle } } } \"\"\" ) _ = self . _gqlclient . execute ( query , variable_values = { \"handle\" : self . _session_id }) def get_embeds ( self ) -> List [ Dict [ str , Any ]]: \"\"\"Return the Embeds attached to this Session.\"\"\" query = gql ( \"\"\" query getEmbeds($handle: String!) { sessionByHandle(handle: $handle) { embeds { key embed { id contentType created contentHash owner { username } url } } } } \"\"\" ) result = self . _gqlclient . execute ( query , variable_values = { \"handle\" : self . _session_id } ) assert ( \"sessionByHandle\" in result and isinstance ( result [ \"sessionByHandle\" ], dict ) and isinstance ( result [ \"sessionByHandle\" ][ \"embeds\" ], list ) ) return result [ \"sessionByHandle\" ][ \"embeds\" ] def get_messages ( self ) -> List [ Dict [ str , Any ]]: \"\"\"Return the messages that make up this session.\"\"\" query = gql ( \"\"\" query getMessages($handle: String!) { sessionByHandle(handle: $handle) { messages { id text sentBy { handle } type inReplyTo { id } timestamp } } } \"\"\" ) result = self . _gqlclient . execute ( query , variable_values = { \"handle\" : self . _session_id } ) assert ( \"sessionByHandle\" in result and isinstance ( result [ \"sessionByHandle\" ], dict ) and isinstance ( result [ \"sessionByHandle\" ][ \"messages\" ], list ) ) return result [ \"sessionByHandle\" ][ \"messages\" ] def add_message ( self , text : str ) -> str : \"\"\"Add a message to this Session. Returns the added message text.\"\"\" query = gql ( \"\"\" mutation Post($handle: String!, $text: String!) { sendSessionMessage(messageData: {session: $handle, text: $text}) { message { text } } } \"\"\" ) result = self . _gqlclient . execute ( query , variable_values = { \"handle\" : self . _session_id , \"text\" : text } ) assert isinstance ( result [ \"sendSessionMessage\" ][ \"message\" ][ \"text\" ], str ) return result [ \"sendSessionMessage\" ][ \"message\" ][ \"text\" ] def query ( self , text : str ) -> str : \"\"\"Run a single query against the Fixie API and return the response.\"\"\" self . add_message ( text ) # The reply to the query comes in as the most recent 'response' message in the # session. response = self . get_messages ()[ - 1 ] assert isinstance ( response [ \"text\" ], str ) return response [ \"text\" ] def run ( self , text : str ) -> Generator [ Dict [ str , Any ], None , None ]: \"\"\"Run a query against the Fixie API, returning a generator that yields messages.\"\"\" # Run the query in the background, and continue polling for replies. background_client = self . clone () threading . Thread ( target = background_client . add_message , args = ( text ,)) . start () response_received = False while not response_received : time . sleep ( 1 ) messages = self . get_messages_since_last_time () for message in messages : response_received = message [ \"type\" ] == \"response\" yield message def get_messages_since_last_time ( self ) -> List [ Dict [ str , Any ]]: \"\"\"Return all messages since the given timestamp.\"\"\" timestamp = self . _last_message_timestamp messages_since_last_time = [] for message in self . get_messages (): message_timestamp = datetime . datetime . fromisoformat ( message [ \"timestamp\" ]) if timestamp is None or message_timestamp > timestamp : messages_since_last_time . append ( message ) self . _last_message_timestamp = message_timestamp return messages_since_last_time frontend_agent_id : Optional [ str ] property Return the frontend agent ID used by this Fixie client. session_id : Optional [ str ] property Return the session ID used by this Fixie client. session_url : str property Return the URL of the Fixie session. add_message ( text ) Add a message to this Session. Returns the added message text. Source code in fixieai/client/session.py 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 def add_message ( self , text : str ) -> str : \"\"\"Add a message to this Session. Returns the added message text.\"\"\" query = gql ( \"\"\" mutation Post($handle: String!, $text: String!) { sendSessionMessage(messageData: {session: $handle, text: $text}) { message { text } } } \"\"\" ) result = self . _gqlclient . execute ( query , variable_values = { \"handle\" : self . _session_id , \"text\" : text } ) assert isinstance ( result [ \"sendSessionMessage\" ][ \"message\" ][ \"text\" ], str ) return result [ \"sendSessionMessage\" ][ \"message\" ][ \"text\" ] clone () Return a new Session instance with the same configuration. Source code in fixieai/client/session.py 64 65 66 def clone ( self ) -> \"Session\" : \"\"\"Return a new Session instance with the same configuration.\"\"\" return Session ( self . _client . clone (), session_id = self . _session_id ) delete_session () Delete the current session. Source code in fixieai/client/session.py 120 121 122 123 124 125 126 127 128 129 130 131 132 133 def delete_session ( self ) -> None : \"\"\"Delete the current session.\"\"\" query = gql ( \"\"\" mutation DeleteSession($handle: String!) { deleteSession(handle: $handle) { session { handle } } } \"\"\" ) _ = self . _gqlclient . execute ( query , variable_values = { \"handle\" : self . _session_id }) get_embeds () Return the Embeds attached to this Session. Source code in fixieai/client/session.py 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 def get_embeds ( self ) -> List [ Dict [ str , Any ]]: \"\"\"Return the Embeds attached to this Session.\"\"\" query = gql ( \"\"\" query getEmbeds($handle: String!) { sessionByHandle(handle: $handle) { embeds { key embed { id contentType created contentHash owner { username } url } } } } \"\"\" ) result = self . _gqlclient . execute ( query , variable_values = { \"handle\" : self . _session_id } ) assert ( \"sessionByHandle\" in result and isinstance ( result [ \"sessionByHandle\" ], dict ) and isinstance ( result [ \"sessionByHandle\" ][ \"embeds\" ], list ) ) return result [ \"sessionByHandle\" ][ \"embeds\" ] get_messages () Return the messages that make up this session. Source code in fixieai/client/session.py 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 def get_messages ( self ) -> List [ Dict [ str , Any ]]: \"\"\"Return the messages that make up this session.\"\"\" query = gql ( \"\"\" query getMessages($handle: String!) { sessionByHandle(handle: $handle) { messages { id text sentBy { handle } type inReplyTo { id } timestamp } } } \"\"\" ) result = self . _gqlclient . execute ( query , variable_values = { \"handle\" : self . _session_id } ) assert ( \"sessionByHandle\" in result and isinstance ( result [ \"sessionByHandle\" ], dict ) and isinstance ( result [ \"sessionByHandle\" ][ \"messages\" ], list ) ) return result [ \"sessionByHandle\" ][ \"messages\" ] get_messages_since_last_time () Return all messages since the given timestamp. Source code in fixieai/client/session.py 242 243 244 245 246 247 248 249 250 251 def get_messages_since_last_time ( self ) -> List [ Dict [ str , Any ]]: \"\"\"Return all messages since the given timestamp.\"\"\" timestamp = self . _last_message_timestamp messages_since_last_time = [] for message in self . get_messages (): message_timestamp = datetime . datetime . fromisoformat ( message [ \"timestamp\" ]) if timestamp is None or message_timestamp > timestamp : messages_since_last_time . append ( message ) self . _last_message_timestamp = message_timestamp return messages_since_last_time get_metadata () Return metadata about this session. Source code in fixieai/client/session.py 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 def get_metadata ( self ) -> Dict [ str , Any ]: \"\"\"Return metadata about this session.\"\"\" query = gql ( \"\"\" query getSession($session_id: String!) { sessionByHandle(handle: $session_id) { handle name description frontendAgentId } } \"\"\" ) result = self . _gqlclient . execute ( query , variable_values = { \"session_id\" : self . _session_id } ) assert \"sessionByHandle\" in result and isinstance ( result [ \"sessionByHandle\" ], dict ) self . _frontend_agent_id = result [ \"sessionByHandle\" ][ \"frontendAgentId\" ] return result [ \"sessionByHandle\" ] query ( text ) Run a single query against the Fixie API and return the response. Source code in fixieai/client/session.py 217 218 219 220 221 222 223 224 def query ( self , text : str ) -> str : \"\"\"Run a single query against the Fixie API and return the response.\"\"\" self . add_message ( text ) # The reply to the query comes in as the most recent 'response' message in the # session. response = self . get_messages ()[ - 1 ] assert isinstance ( response [ \"text\" ], str ) return response [ \"text\" ] run ( text ) Run a query against the Fixie API, returning a generator that yields messages. Source code in fixieai/client/session.py 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 def run ( self , text : str ) -> Generator [ Dict [ str , Any ], None , None ]: \"\"\"Run a query against the Fixie API, returning a generator that yields messages.\"\"\" # Run the query in the background, and continue polling for replies. background_client = self . clone () threading . Thread ( target = background_client . add_message , args = ( text ,)) . start () response_received = False while not response_received : time . sleep ( 1 ) messages = self . get_messages_since_last_time () for message in messages : response_received = message [ \"type\" ] == \"response\" yield message Agent Provides an interface to the Fixie GraphQL Agent API. Parameters: Name Type Description Default client FixieClient The FixieClient instance to use. required agent_id str The Agent ID, e.g., \"fixie/calc\", or handle, e.g., \"dice\". required Source code in fixieai/client/agent.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 class Agent : \"\"\"Provides an interface to the Fixie GraphQL Agent API. Args: client: The FixieClient instance to use. agent_id: The Agent ID, e.g., \"fixie/calc\", or handle, e.g., \"dice\". \"\"\" def __init__ ( self , client : FixieClient , agent_id : str , ): self . _client = client self . _gqlclient = self . _client . gqlclient self . _agent_id = agent_id self . _owner : Optional [ str ] = None if \"/\" in agent_id : self . _owner , self . _handle = agent_id . split ( \"/\" ) else : self . _handle = agent_id self . _metadata : Optional [ Dict [ str , Any ]] = None try : self . _metadata = self . get_metadata () except : self . _metadata = None @property def agent_id ( self ) -> str : \"\"\"Return the agentId for this Agent.\"\"\" return self . _agent_id @property def handle ( self ) -> str : \"\"\"Return the handle for this Agent.\"\"\" return self . _handle @property def valid ( self ) -> bool : \"\"\"Return whether this Agent is valid.\"\"\" return self . _metadata is not None @property def name ( self ) -> Optional [ str ]: \"\"\"Return the name for this Agent.\"\"\" if self . _metadata is None : return None name = self . _metadata [ \"name\" ] assert name is None or isinstance ( name , str ) return name @property def description ( self ) -> Optional [ str ]: \"\"\"Return the description for this Agent.\"\"\" if self . _metadata is None : return None description = self . _metadata [ \"description\" ] assert description is None or isinstance ( description , str ) return description @property def queries ( self ) -> Optional [ List [ str ]]: \"\"\"Return the queries for this Agent.\"\"\" if self . _metadata is None : return None queries = self . _metadata [ \"queries\" ] assert queries is None or ( isinstance ( queries , list ) and all ( isinstance ( q , str ) for q in queries ) ) return queries @property def more_info_url ( self ) -> Optional [ str ]: \"\"\"Return the more info URL for this Agent.\"\"\" if self . _metadata is None : return None more_info_url = self . _metadata [ \"moreInfoUrl\" ] assert more_info_url is None or isinstance ( more_info_url , str ) return more_info_url @property def published ( self ) -> Optional [ bool ]: \"\"\"Return the published status for this Agent.\"\"\" if self . _metadata is None : return None published = self . _metadata [ \"published\" ] assert published is None or isinstance ( published , bool ) return published @property def owner ( self ) -> Optional [ str ]: \"\"\"Return the owner of this Agent.\"\"\" if self . _metadata is None : return None owner_username = self . _metadata [ \"owner\" ][ \"username\" ] assert owner_username is None or isinstance ( owner_username , str ) return owner_username @property def query_url ( self ) -> Optional [ str ]: \"\"\"Return the query URL for this Agent.\"\"\" if self . _metadata is None : return None url = self . _metadata [ \"queryUrl\" ] assert url is None or isinstance ( url , str ) return url @property def func_url ( self ) -> Optional [ str ]: \"\"\"Return the func URL for this Agent.\"\"\" if self . _metadata is None : return None url = self . _metadata [ \"funcUrl\" ] assert url is None or isinstance ( url , str ) return url @property def created ( self ) -> Optional [ datetime . datetime ]: \"\"\"Return the creation timestamp for this Agent.\"\"\" if self . _metadata is None : return None ts = self . _metadata [ \"created\" ] if ts is not None : return datetime . datetime . fromisoformat ( ts ) else : return None @property def modified ( self ) -> Optional [ datetime . datetime ]: \"\"\"Return the modification timestamp for this Agent.\"\"\" if self . _metadata is None : return None ts = self . _metadata [ \"modified\" ] if ts is not None : return datetime . datetime . fromisoformat ( ts ) else : return None def get_metadata ( self ) -> Dict [ str , Any ]: \"\"\"Return metadata about this Agent.\"\"\" if self . _owner is None : # Query by handle. query = gql ( \"\"\" query getAgentByHandle($handle: String!) { agentByHandle(handle: $handle) { agentId handle name description queries moreInfoUrl published owner { username } queryUrl funcUrl created modified } } \"\"\" ) result = self . _gqlclient . execute ( query , variable_values = { \"handle\" : self . _handle } ) if \"agentByHandle\" not in result or result [ \"agentByHandle\" ] is None : raise ValueError ( f \"Cannot fetch agent metadata for { self . _handle } \" ) agent_dict = result [ \"agentByHandle\" ] else : # Query by agent ID. query = gql ( \"\"\" query getAgentById($agentId: String!) { agentById(agentId: $agentId) { agentId handle name description queries moreInfoUrl published owner { username } queryUrl funcUrl created modified } } \"\"\" ) result = self . _gqlclient . execute ( query , variable_values = { \"agentId\" : f \" { self . _owner } / { self . _handle } \" } ) if \"agentById\" not in result or result [ \"agentById\" ] is None : raise ValueError ( f \"Cannot fetch agent metadata for { self . _owner } / { self . _handle } \" ) agent_dict = result [ \"agentById\" ] assert isinstance ( agent_dict , dict ) and all ( isinstance ( k , str ) for k in agent_dict . keys () ) return agent_dict def create_agent ( self , name : Optional [ str ], description : str , query_url : Optional [ str ] = None , func_url : Optional [ str ] = None , more_info_url : Optional [ str ] = None , published : Optional [ bool ] = None , ) -> str : \"\"\"Create a new Agent with the given parameters.\"\"\" query = gql ( \"\"\" mutation CreateAgent( $handle: String!, $name: String, $description: String!, $queryUrl: String, $funcUrl: String, $moreInfoUrl: String, $published: Boolean) { createAgent( agentData: { handle: $handle, name: $name, description: $description, queryUrl: $queryUrl, funcUrl: $funcUrl, moreInfoUrl: $moreInfoUrl, published: $published } ) { agent { agentId } } } \"\"\" ) variable_values : Dict [ str , Any ] = { \"handle\" : self . _handle } if name is not None : variable_values [ \"name\" ] = name variable_values [ \"description\" ] = description if query_url is not None : variable_values [ \"queryUrl\" ] = query_url if func_url is not None : variable_values [ \"funcUrl\" ] = func_url if more_info_url is not None : variable_values [ \"moreInfoUrl\" ] = more_info_url if published is not None : variable_values [ \"published\" ] = published result = self . _gqlclient . execute ( query , variable_values = variable_values ) if \"createAgent\" not in result or result [ \"createAgent\" ] is None : raise ValueError ( f \"Failed to create Agent\" ) assert isinstance ( result [ \"createAgent\" ], dict ) assert isinstance ( result [ \"createAgent\" ][ \"agent\" ], dict ) assert isinstance ( result [ \"createAgent\" ][ \"agent\" ][ \"agentId\" ], str ) self . _metadata = self . get_metadata () return result [ \"createAgent\" ][ \"agent\" ][ \"agentId\" ] def update_agent ( self , new_handle : Optional [ str ] = None , name : Optional [ str ] = None , description : Optional [ str ] = None , query_url : Optional [ str ] = None , func_url : Optional [ str ] = None , more_info_url : Optional [ str ] = None , published : Optional [ bool ] = None , ) -> str : \"\"\"Update the Agent with the given parameters.\"\"\" query = gql ( \"\"\" mutation UpdateAgent( $handle: String!, $newHandle: String, $name: String, $description: String, $queryUrl: String, $funcUrl: String, $moreInfoUrl: String, $published: Boolean) { updateAgent( agentData: { handle: $handle, newHandle: $newHandle, name: $name, description: $description, queryUrl: $queryUrl, funcUrl: $funcUrl, moreInfoUrl: $moreInfoUrl, published: $published } ) { agent { agentId } } } \"\"\" ) variable_values : Dict [ str , Any ] = { \"handle\" : self . _handle } if new_handle is not None : variable_values [ \"newHandle\" ] = new_handle if name is not None : variable_values [ \"name\" ] = name if description is not None : variable_values [ \"description\" ] = description if query_url is not None : variable_values [ \"queryUrl\" ] = query_url if func_url is not None : variable_values [ \"funcUrl\" ] = func_url if more_info_url is not None : variable_values [ \"moreInfoUrl\" ] = more_info_url if published is not None : variable_values [ \"published\" ] = published result = self . _gqlclient . execute ( query , variable_values = variable_values ) if \"updateAgent\" not in result or result [ \"updateAgent\" ] is None : raise ValueError ( f \"Failed to update Agent\" ) assert isinstance ( result [ \"updateAgent\" ], dict ) assert isinstance ( result [ \"updateAgent\" ][ \"agent\" ], dict ) assert isinstance ( result [ \"updateAgent\" ][ \"agent\" ][ \"agentId\" ], str ) self . _metadata = self . get_metadata () if new_handle : self . _handle = new_handle return result [ \"updateAgent\" ][ \"agent\" ][ \"agentId\" ] def delete_agent ( self ) -> None : \"\"\"Delete this Agent.\"\"\" query = gql ( \"\"\" mutation DeleteAgent($handle: String!) { deleteAgent(handle: $handle) { agent { handle } } } \"\"\" ) _ = self . _gqlclient . execute ( query , variable_values = { \"handle\" : self . _handle }) agent_id : str property Return the agentId for this Agent. created : Optional [ datetime . datetime ] property Return the creation timestamp for this Agent. description : Optional [ str ] property Return the description for this Agent. func_url : Optional [ str ] property Return the func URL for this Agent. handle : str property Return the handle for this Agent. modified : Optional [ datetime . datetime ] property Return the modification timestamp for this Agent. more_info_url : Optional [ str ] property Return the more info URL for this Agent. name : Optional [ str ] property Return the name for this Agent. owner : Optional [ str ] property Return the owner of this Agent. published : Optional [ bool ] property Return the published status for this Agent. queries : Optional [ List [ str ]] property Return the queries for this Agent. query_url : Optional [ str ] property Return the query URL for this Agent. valid : bool property Return whether this Agent is valid. create_agent ( name , description , query_url = None , func_url = None , more_info_url = None , published = None ) Create a new Agent with the given parameters. Source code in fixieai/client/agent.py 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 def create_agent ( self , name : Optional [ str ], description : str , query_url : Optional [ str ] = None , func_url : Optional [ str ] = None , more_info_url : Optional [ str ] = None , published : Optional [ bool ] = None , ) -> str : \"\"\"Create a new Agent with the given parameters.\"\"\" query = gql ( \"\"\" mutation CreateAgent( $handle: String!, $name: String, $description: String!, $queryUrl: String, $funcUrl: String, $moreInfoUrl: String, $published: Boolean) { createAgent( agentData: { handle: $handle, name: $name, description: $description, queryUrl: $queryUrl, funcUrl: $funcUrl, moreInfoUrl: $moreInfoUrl, published: $published } ) { agent { agentId } } } \"\"\" ) variable_values : Dict [ str , Any ] = { \"handle\" : self . _handle } if name is not None : variable_values [ \"name\" ] = name variable_values [ \"description\" ] = description if query_url is not None : variable_values [ \"queryUrl\" ] = query_url if func_url is not None : variable_values [ \"funcUrl\" ] = func_url if more_info_url is not None : variable_values [ \"moreInfoUrl\" ] = more_info_url if published is not None : variable_values [ \"published\" ] = published result = self . _gqlclient . execute ( query , variable_values = variable_values ) if \"createAgent\" not in result or result [ \"createAgent\" ] is None : raise ValueError ( f \"Failed to create Agent\" ) assert isinstance ( result [ \"createAgent\" ], dict ) assert isinstance ( result [ \"createAgent\" ][ \"agent\" ], dict ) assert isinstance ( result [ \"createAgent\" ][ \"agent\" ][ \"agentId\" ], str ) self . _metadata = self . get_metadata () return result [ \"createAgent\" ][ \"agent\" ][ \"agentId\" ] delete_agent () Delete this Agent. Source code in fixieai/client/agent.py 358 359 360 361 362 363 364 365 366 367 368 369 370 371 def delete_agent ( self ) -> None : \"\"\"Delete this Agent.\"\"\" query = gql ( \"\"\" mutation DeleteAgent($handle: String!) { deleteAgent(handle: $handle) { agent { handle } } } \"\"\" ) _ = self . _gqlclient . execute ( query , variable_values = { \"handle\" : self . _handle }) get_metadata () Return metadata about this Agent. Source code in fixieai/client/agent.py 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 def get_metadata ( self ) -> Dict [ str , Any ]: \"\"\"Return metadata about this Agent.\"\"\" if self . _owner is None : # Query by handle. query = gql ( \"\"\" query getAgentByHandle($handle: String!) { agentByHandle(handle: $handle) { agentId handle name description queries moreInfoUrl published owner { username } queryUrl funcUrl created modified } } \"\"\" ) result = self . _gqlclient . execute ( query , variable_values = { \"handle\" : self . _handle } ) if \"agentByHandle\" not in result or result [ \"agentByHandle\" ] is None : raise ValueError ( f \"Cannot fetch agent metadata for { self . _handle } \" ) agent_dict = result [ \"agentByHandle\" ] else : # Query by agent ID. query = gql ( \"\"\" query getAgentById($agentId: String!) { agentById(agentId: $agentId) { agentId handle name description queries moreInfoUrl published owner { username } queryUrl funcUrl created modified } } \"\"\" ) result = self . _gqlclient . execute ( query , variable_values = { \"agentId\" : f \" { self . _owner } / { self . _handle } \" } ) if \"agentById\" not in result or result [ \"agentById\" ] is None : raise ValueError ( f \"Cannot fetch agent metadata for { self . _owner } / { self . _handle } \" ) agent_dict = result [ \"agentById\" ] assert isinstance ( agent_dict , dict ) and all ( isinstance ( k , str ) for k in agent_dict . keys () ) return agent_dict update_agent ( new_handle = None , name = None , description = None , query_url = None , func_url = None , more_info_url = None , published = None ) Update the Agent with the given parameters. Source code in fixieai/client/agent.py 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 def update_agent ( self , new_handle : Optional [ str ] = None , name : Optional [ str ] = None , description : Optional [ str ] = None , query_url : Optional [ str ] = None , func_url : Optional [ str ] = None , more_info_url : Optional [ str ] = None , published : Optional [ bool ] = None , ) -> str : \"\"\"Update the Agent with the given parameters.\"\"\" query = gql ( \"\"\" mutation UpdateAgent( $handle: String!, $newHandle: String, $name: String, $description: String, $queryUrl: String, $funcUrl: String, $moreInfoUrl: String, $published: Boolean) { updateAgent( agentData: { handle: $handle, newHandle: $newHandle, name: $name, description: $description, queryUrl: $queryUrl, funcUrl: $funcUrl, moreInfoUrl: $moreInfoUrl, published: $published } ) { agent { agentId } } } \"\"\" ) variable_values : Dict [ str , Any ] = { \"handle\" : self . _handle } if new_handle is not None : variable_values [ \"newHandle\" ] = new_handle if name is not None : variable_values [ \"name\" ] = name if description is not None : variable_values [ \"description\" ] = description if query_url is not None : variable_values [ \"queryUrl\" ] = query_url if func_url is not None : variable_values [ \"funcUrl\" ] = func_url if more_info_url is not None : variable_values [ \"moreInfoUrl\" ] = more_info_url if published is not None : variable_values [ \"published\" ] = published result = self . _gqlclient . execute ( query , variable_values = variable_values ) if \"updateAgent\" not in result or result [ \"updateAgent\" ] is None : raise ValueError ( f \"Failed to update Agent\" ) assert isinstance ( result [ \"updateAgent\" ], dict ) assert isinstance ( result [ \"updateAgent\" ][ \"agent\" ], dict ) assert isinstance ( result [ \"updateAgent\" ][ \"agent\" ][ \"agentId\" ], str ) self . _metadata = self . get_metadata () if new_handle : self . _handle = new_handle return result [ \"updateAgent\" ][ \"agent\" ][ \"agentId\" ] fixie ( ctx ) Command-line interface to the Fixie platform. Source code in fixieai/cli/cli.py 34 35 36 37 38 @click . group () @click . pass_context def fixie ( ctx ): \"\"\"Command-line interface to the Fixie platform.\"\"\" ctx . ensure_object ( CliContext ) Console A simple console interface for Fixie. Source code in fixieai/cli/session/console.py 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 class Console : \"\"\"A simple console interface for Fixie.\"\"\" def __init__ ( self , client : FixieClient , session : Session , history_file : str = HISTORY_FILE , ): self . _client = client self . _session = session history_file = os . path . expanduser ( history_file ) os . makedirs ( os . path . dirname ( history_file ), exist_ok = True ) self . _history_file = history_file self . _response_index = 0 def run ( self , initial_message : Optional [ str ] = None , ) -> None : \"\"\"Run the console application.\"\"\" textconsole . print ( \"[blue]Welcome to Fixie!\" ) textconsole . print ( f \"Connected to: { self . _session . session_url } \" ) # Show what's already in the session thus far. for message in self . _session . get_messages_since_last_time (): self . _show_message ( message , show_user_message = True ) history = prompt_toolkit . history . FileHistory ( self . _history_file ) if initial_message : prompt_toolkit . print_formatted_text ( f \" { PROMPT }{ initial_message } \" ) history . append_string ( initial_message ) self . _query ( initial_message ) while True : in_text = prompt_toolkit . prompt ( PROMPT , history = history , auto_suggest = prompt_toolkit . auto_suggest . AutoSuggestFromHistory (), ) self . _query ( in_text ) def _query ( self , in_text : str ) -> None : with textconsole . status ( \"Working...\" , spinner = \"bouncingBall\" ): try : for message in self . _session . run ( in_text ): self . _show_message ( message ) except requests . exceptions . HTTPError as e : textconsole . print ( f \"\ud83d\udea8 { e } \" ) return def _show_message ( self , message : Dict [ str , Any ], show_user_message : bool = False ): \"\"\"Shows a message dict from FixieClient. If show_user_message is set, the user messages are also printed with the PROMPT. This option is useful for showing previous messages in the chat when connecting to a session. \"\"\" sender_handle = ( message [ \"sentBy\" ][ \"handle\" ] if message [ \"sentBy\" ] else \"<unknown>\" ) if message [ \"type\" ] == \"query\" and sender_handle == \"user\" : if show_user_message : textconsole . print ( f \" { PROMPT }{ markup . escape ( message [ 'text' ]) } \" ) elif message [ \"type\" ] != \"response\" : textconsole . print ( f \" [dim]@ { sender_handle } : { markup . escape ( message [ 'text' ]) } [/]\" ) else : self . _response_index += 1 textconsole . print ( f \" { self . _response_index } \u276f { markup . escape ( message [ 'text' ]) } \" ) self . _show_embeds ( message [ \"text\" ]) def _show_embeds ( self , message : str ): \"\"\"Shows embeds referenced in `message_text`.\"\"\" # Check embed references in message (denoted by #id). embed_ids = _extract_embed_refs ( message ) if not embed_ids : return # Get a dict of all embed_id -> embeds in the session. embeds = { embed_dict [ \"key\" ]: embed_dict [ \"embed\" ] for embed_dict in self . _session . get_embeds () } # Show what we can find. for embed_id in embed_ids : if embed_id not in embeds : textconsole . print ( f \" [dim]embed # { embed_id } not found in session[/]\" , style = \"red\" ) continue _show_embed ( embeds [ embed_id ][ \"url\" ], embeds [ embed_id ][ \"contentType\" ], ) run ( initial_message = None ) Run the console application. Source code in fixieai/cli/session/console.py 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 def run ( self , initial_message : Optional [ str ] = None , ) -> None : \"\"\"Run the console application.\"\"\" textconsole . print ( \"[blue]Welcome to Fixie!\" ) textconsole . print ( f \"Connected to: { self . _session . session_url } \" ) # Show what's already in the session thus far. for message in self . _session . get_messages_since_last_time (): self . _show_message ( message , show_user_message = True ) history = prompt_toolkit . history . FileHistory ( self . _history_file ) if initial_message : prompt_toolkit . print_formatted_text ( f \" { PROMPT }{ initial_message } \" ) history . append_string ( initial_message ) self . _query ( initial_message ) while True : in_text = prompt_toolkit . prompt ( PROMPT , history = history , auto_suggest = prompt_toolkit . auto_suggest . AutoSuggestFromHistory (), ) self . _query ( in_text )","title":"Python Client API"},{"location":"python-client-api/#fixie-client-python-api-reference","text":"","title":"Fixie Client Python API Reference"},{"location":"python-client-api/#fixieai.client.client.FixieClient","text":"FixieClient is a client to the Fixie system. Parameters: Name Type Description Default api_key Optional [ str ] The API key for the Fixie API server. If not provided, the FIXIE_API_KEY environment variable will be used. If that is not set, the authenticated user API key will be used, or a ValueError will be raised if the user is not authenticated. None Source code in fixieai/client/client.py 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 class FixieClient : \"\"\"FixieClient is a client to the Fixie system. Args: api_key: The API key for the Fixie API server. If not provided, the FIXIE_API_KEY environment variable will be used. If that is not set, the authenticated user API key will be used, or a ValueError will be raised if the user is not authenticated. \"\"\" def __init__ ( self , api_key : Optional [ str ] = None , ): self . _api_key = api_key or constants . fixie_api_key () logging . info ( f \"Using Fixie API URL: { constants . FIXIE_API_URL } \" ) self . _request_headers = { \"Authorization\" : f \"Bearer { self . _api_key } \" } transport = RequestsHTTPTransport ( url = constants . FIXIE_GRAPHQL_URL , headers = self . _request_headers , ) self . _gqlclient = Client ( transport = transport , fetch_schema_from_transport = False ) @property def gqlclient ( self ) -> Client : \"\"\"Return the underlying GraphQL client used by this FixieClient.\"\"\" return self . _gqlclient @property def url ( self ) -> str : \"\"\"Return the URL of the Fixie API server.\"\"\" return constants . FIXIE_API_URL def clone ( self ) -> \"FixieClient\" : \"\"\"Return a new FixieClient instance with the same configuration.\"\"\" return FixieClient ( api_key = self . _api_key ) def get_agents ( self ) -> Dict [ str , Dict [ str , str ]]: \"\"\"Return metadata about all running Fixie Agents. The keys of the returned dictionary are the Agent handles, and the values are dictionaries containing metadata about each Agent.\"\"\" query = gql ( \"\"\" query getAgents { allAgents { agentId name description moreInfoUrl } } \"\"\" ) result = self . _gqlclient . execute ( query ) assert \"allAgents\" in result and isinstance ( result [ \"allAgents\" ], list ) agents = result [ \"allAgents\" ] return { agent [ \"agentId\" ]: agent for agent in agents } def get_agent ( self , agent_id : str ) -> Agent : \"\"\"Return an existing Agent object.\"\"\" return Agent ( self , agent_id ) def create_agent ( self , handle : str , name : str , description : str , query_url : Optional [ str ] = None , func_url : Optional [ str ] = None , more_info_url : Optional [ str ] = None , published : Optional [ bool ] = None , ) -> Agent : \"\"\"Create a new Agent. Args: handle: The handle for the new Agent. This must be unique across all Agents owned by this user. name: The name of the new Agent. description: A description of the new Agent. query_url: The URL of the new Agent's query endpoint. func_url: The URL of the new Agent's func endpoint. more_info_url: A URL with more information about the new Agent. published: Whether the new Agent should be published. \"\"\" agent = Agent ( self , f \" { self . get_current_username () } / { handle } \" ) agent . create_agent ( name , description , query_url , func_url , more_info_url , published ) return agent def get_sessions ( self ) -> List [ str ]: \"\"\"Return a list of all session IDs.\"\"\" query = gql ( \"\"\" query getSessions { allSessions { handle } } \"\"\" ) result = self . _gqlclient . execute ( query ) assert \"allSessions\" in result and isinstance ( result [ \"allSessions\" ], list ) sessions = result [ \"allSessions\" ] return [ session [ \"handle\" ] for session in sessions ] def create_session ( self , frontend_agent_id : Optional [ str ] = None ) -> Session : \"\"\"Create a new Session.\"\"\" return Session ( self , frontend_agent_id = frontend_agent_id ) def get_session ( self , session_id : str ) -> Session : \"\"\"Return an existing Session object.\"\"\" return Session ( self , session_id ) def get_current_username ( self ) -> str : \"\"\"Returns the username of the current user.\"\"\" query = gql ( \"\"\" query getUsername { user { username } } \"\"\" ) result = self . _gqlclient . execute ( query ) assert \"user\" in result and isinstance ( result [ \"user\" ], dict ) user = result [ \"user\" ] assert \"username\" in user and isinstance ( user [ \"username\" ], str ) return user [ \"username\" ] def refresh_agent ( self , agent_handle : str ): \"\"\"Indicates that an agent's prompts should be refreshed.\"\"\" username = self . get_current_username () requests . post ( f \" { constants . FIXIE_REFRESH_URL } / { username } / { agent_handle } \" , headers = self . _request_headers , ) . raise_for_status () def deploy_agent ( self , handle : str , gzip_tarfile : BinaryIO , ): \"\"\"Deploys an agent implementation. Args: handle: The handle of the Agent to deploy. Must be owned by the current user. gzip_tarfile: A file-like of a gzip-compressed tarfile containing the files to deploy. \"\"\" username = self . get_current_username () requests . post ( f \" { constants . FIXIE_DEPLOYMENT_URL } / { username } / { handle } \" , headers = self . _request_headers , files = { \"agent.tar.gz\" : ( \"agent.tar.gz\" , gzip_tarfile , \"application/gzip\" )}, ) . raise_for_status ()","title":"FixieClient"},{"location":"python-client-api/#fixieai.client.client.FixieClient.gqlclient","text":"Return the underlying GraphQL client used by this FixieClient.","title":"gqlclient"},{"location":"python-client-api/#fixieai.client.client.FixieClient.url","text":"Return the URL of the Fixie API server.","title":"url"},{"location":"python-client-api/#fixieai.client.client.FixieClient.clone","text":"Return a new FixieClient instance with the same configuration. Source code in fixieai/client/client.py 89 90 91 def clone ( self ) -> \"FixieClient\" : \"\"\"Return a new FixieClient instance with the same configuration.\"\"\" return FixieClient ( api_key = self . _api_key )","title":"clone()"},{"location":"python-client-api/#fixieai.client.client.FixieClient.create_agent","text":"Create a new Agent. Parameters: Name Type Description Default handle str The handle for the new Agent. This must be unique across all Agents owned by this user. required name str The name of the new Agent. required description str A description of the new Agent. required query_url Optional [ str ] The URL of the new Agent's query endpoint. None func_url Optional [ str ] The URL of the new Agent's func endpoint. None more_info_url Optional [ str ] A URL with more information about the new Agent. None published Optional [ bool ] Whether the new Agent should be published. None Source code in fixieai/client/client.py 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 def create_agent ( self , handle : str , name : str , description : str , query_url : Optional [ str ] = None , func_url : Optional [ str ] = None , more_info_url : Optional [ str ] = None , published : Optional [ bool ] = None , ) -> Agent : \"\"\"Create a new Agent. Args: handle: The handle for the new Agent. This must be unique across all Agents owned by this user. name: The name of the new Agent. description: A description of the new Agent. query_url: The URL of the new Agent's query endpoint. func_url: The URL of the new Agent's func endpoint. more_info_url: A URL with more information about the new Agent. published: Whether the new Agent should be published. \"\"\" agent = Agent ( self , f \" { self . get_current_username () } / { handle } \" ) agent . create_agent ( name , description , query_url , func_url , more_info_url , published ) return agent","title":"create_agent()"},{"location":"python-client-api/#fixieai.client.client.FixieClient.create_session","text":"Create a new Session. Source code in fixieai/client/client.py 164 165 166 def create_session ( self , frontend_agent_id : Optional [ str ] = None ) -> Session : \"\"\"Create a new Session.\"\"\" return Session ( self , frontend_agent_id = frontend_agent_id )","title":"create_session()"},{"location":"python-client-api/#fixieai.client.client.FixieClient.deploy_agent","text":"Deploys an agent implementation. Parameters: Name Type Description Default handle str The handle of the Agent to deploy. Must be owned by the current user. required gzip_tarfile BinaryIO A file-like of a gzip-compressed tarfile containing the files to deploy. required Source code in fixieai/client/client.py 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 def deploy_agent ( self , handle : str , gzip_tarfile : BinaryIO , ): \"\"\"Deploys an agent implementation. Args: handle: The handle of the Agent to deploy. Must be owned by the current user. gzip_tarfile: A file-like of a gzip-compressed tarfile containing the files to deploy. \"\"\" username = self . get_current_username () requests . post ( f \" { constants . FIXIE_DEPLOYMENT_URL } / { username } / { handle } \" , headers = self . _request_headers , files = { \"agent.tar.gz\" : ( \"agent.tar.gz\" , gzip_tarfile , \"application/gzip\" )}, ) . raise_for_status ()","title":"deploy_agent()"},{"location":"python-client-api/#fixieai.client.client.FixieClient.get_agent","text":"Return an existing Agent object. Source code in fixieai/client/client.py 115 116 117 def get_agent ( self , agent_id : str ) -> Agent : \"\"\"Return an existing Agent object.\"\"\" return Agent ( self , agent_id )","title":"get_agent()"},{"location":"python-client-api/#fixieai.client.client.FixieClient.get_agents","text":"Return metadata about all running Fixie Agents. The keys of the returned dictionary are the Agent handles, and the values are dictionaries containing metadata about each Agent. Source code in fixieai/client/client.py 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 def get_agents ( self ) -> Dict [ str , Dict [ str , str ]]: \"\"\"Return metadata about all running Fixie Agents. The keys of the returned dictionary are the Agent handles, and the values are dictionaries containing metadata about each Agent.\"\"\" query = gql ( \"\"\" query getAgents { allAgents { agentId name description moreInfoUrl } } \"\"\" ) result = self . _gqlclient . execute ( query ) assert \"allAgents\" in result and isinstance ( result [ \"allAgents\" ], list ) agents = result [ \"allAgents\" ] return { agent [ \"agentId\" ]: agent for agent in agents }","title":"get_agents()"},{"location":"python-client-api/#fixieai.client.client.FixieClient.get_current_username","text":"Returns the username of the current user. Source code in fixieai/client/client.py 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 def get_current_username ( self ) -> str : \"\"\"Returns the username of the current user.\"\"\" query = gql ( \"\"\" query getUsername { user { username } } \"\"\" ) result = self . _gqlclient . execute ( query ) assert \"user\" in result and isinstance ( result [ \"user\" ], dict ) user = result [ \"user\" ] assert \"username\" in user and isinstance ( user [ \"username\" ], str ) return user [ \"username\" ]","title":"get_current_username()"},{"location":"python-client-api/#fixieai.client.client.FixieClient.get_session","text":"Return an existing Session object. Source code in fixieai/client/client.py 168 169 170 def get_session ( self , session_id : str ) -> Session : \"\"\"Return an existing Session object.\"\"\" return Session ( self , session_id )","title":"get_session()"},{"location":"python-client-api/#fixieai.client.client.FixieClient.get_sessions","text":"Return a list of all session IDs. Source code in fixieai/client/client.py 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 def get_sessions ( self ) -> List [ str ]: \"\"\"Return a list of all session IDs.\"\"\" query = gql ( \"\"\" query getSessions { allSessions { handle } } \"\"\" ) result = self . _gqlclient . execute ( query ) assert \"allSessions\" in result and isinstance ( result [ \"allSessions\" ], list ) sessions = result [ \"allSessions\" ] return [ session [ \"handle\" ] for session in sessions ]","title":"get_sessions()"},{"location":"python-client-api/#fixieai.client.client.FixieClient.refresh_agent","text":"Indicates that an agent's prompts should be refreshed. Source code in fixieai/client/client.py 189 190 191 192 193 194 195 def refresh_agent ( self , agent_handle : str ): \"\"\"Indicates that an agent's prompts should be refreshed.\"\"\" username = self . get_current_username () requests . post ( f \" { constants . FIXIE_REFRESH_URL } / { username } / { agent_handle } \" , headers = self . _request_headers , ) . raise_for_status ()","title":"refresh_agent()"},{"location":"python-client-api/#fixieai.client.client.get_agents","text":"Return metadata about all Fixie Agents. The keys of the returned dictionary are Agent IDs, and the values are dictionaries containing metadata about each Agent. Source code in fixieai/client/client.py 39 40 41 42 43 def get_agents () -> Dict [ str , Dict [ str , str ]]: \"\"\"Return metadata about all Fixie Agents. The keys of the returned dictionary are Agent IDs, and the values are dictionaries containing metadata about each Agent.\"\"\" return get_client () . get_agents ()","title":"get_agents()"},{"location":"python-client-api/#fixieai.client.client.get_client","text":"Return the global FixieClient instance. Source code in fixieai/client/client.py 21 22 23 24 25 26 27 def get_client () -> FixieClient : \"\"\"Return the global FixieClient instance.\"\"\" global _CLIENT if not _CLIENT : _CLIENT = FixieClient () assert _CLIENT is not None return _CLIENT","title":"get_client()"},{"location":"python-client-api/#fixieai.client.client.get_embeds","text":"Return a list of Embeds. Source code in fixieai/client/client.py 51 52 53 def get_embeds () -> List [ Dict [ str , Any ]]: \"\"\"Return a list of Embeds.\"\"\" return get_session () . get_embeds ()","title":"get_embeds()"},{"location":"python-client-api/#fixieai.client.client.get_session","text":"Return the global Fixie Session instance. Source code in fixieai/client/client.py 30 31 32 33 34 35 36 def get_session () -> Session : \"\"\"Return the global Fixie Session instance.\"\"\" global _SESSION if not _SESSION : _SESSION = Session ( get_client ()) assert _SESSION is not None return _SESSION","title":"get_session()"},{"location":"python-client-api/#fixieai.client.client.query","text":"Run a query. Source code in fixieai/client/client.py 46 47 48 def query ( text : str ) -> str : \"\"\"Run a query.\"\"\" return get_session () . query ( text )","title":"query()"},{"location":"python-client-api/#fixieai.client.session.Session","text":"Represents a single session with the Fixie system. Parameters: Name Type Description Default client FixieClient The FixieClient instance to use. required session_id Optional [ str ] The ID of the session to use. If not provided, a new session will be created. None Source code in fixieai/client/session.py 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 class Session : \"\"\"Represents a single session with the Fixie system. Args: client: The FixieClient instance to use. session_id: The ID of the session to use. If not provided, a new session will be created. \"\"\" def __init__ ( self , client : FixieClient , session_id : Optional [ str ] = None , frontend_agent_id : Optional [ str ] = None , ): self . _client = client self . _gqlclient = self . _client . gqlclient self . _session_id = session_id if session_id : # Test that the session exists. _ = self . get_metadata () assert ( frontend_agent_id is None ), \"Cannot specify frontend_agent_id when using an existing session\" else : self . _session_id = self . _create_session ( frontend_agent_id ) self . _frontend_agent_id : Optional [ str ] = None self . _last_message_timestamp : Optional [ datetime . datetime ] = None @property def session_id ( self ) -> Optional [ str ]: \"\"\"Return the session ID used by this Fixie client.\"\"\" return self . _session_id @property def session_url ( self ) -> str : \"\"\"Return the URL of the Fixie session.\"\"\" return f \" { self . _client . url } /sessions/ { self . session_id } \" @property def frontend_agent_id ( self ) -> Optional [ str ]: \"\"\"Return the frontend agent ID used by this Fixie client.\"\"\" return self . _frontend_agent_id def clone ( self ) -> \"Session\" : \"\"\"Return a new Session instance with the same configuration.\"\"\" return Session ( self . _client . clone (), session_id = self . _session_id ) def _create_session ( self , frontend_agent_id : Optional [ str ] = None ) -> str : \"\"\"Create a new session.\"\"\" assert self . _session_id is None query = gql ( \"\"\" mutation CreateSession($frontendAgentId: String) { createSession(sessionData: {frontendAgentId: $frontendAgentId}) { session { handle frontendAgentId } } } \"\"\" ) result = self . _gqlclient . execute ( query , variable_values = { \"frontendAgentId\" : frontend_agent_id } ) if \"createSession\" not in result or result [ \"createSession\" ] is None : raise ValueError ( f \"Failed to create Session\" ) assert isinstance ( result [ \"createSession\" ], dict ) assert isinstance ( result [ \"createSession\" ][ \"session\" ], dict ) self . _frontend_agent_id = result [ \"createSession\" ][ \"session\" ][ \"frontendAgentId\" ] assert isinstance ( result [ \"createSession\" ][ \"session\" ][ \"handle\" ], str ) return result [ \"createSession\" ][ \"session\" ][ \"handle\" ] def get_metadata ( self ) -> Dict [ str , Any ]: \"\"\"Return metadata about this session.\"\"\" query = gql ( \"\"\" query getSession($session_id: String!) { sessionByHandle(handle: $session_id) { handle name description frontendAgentId } } \"\"\" ) result = self . _gqlclient . execute ( query , variable_values = { \"session_id\" : self . _session_id } ) assert \"sessionByHandle\" in result and isinstance ( result [ \"sessionByHandle\" ], dict ) self . _frontend_agent_id = result [ \"sessionByHandle\" ][ \"frontendAgentId\" ] return result [ \"sessionByHandle\" ] def delete_session ( self ) -> None : \"\"\"Delete the current session.\"\"\" query = gql ( \"\"\" mutation DeleteSession($handle: String!) { deleteSession(handle: $handle) { session { handle } } } \"\"\" ) _ = self . _gqlclient . execute ( query , variable_values = { \"handle\" : self . _session_id }) def get_embeds ( self ) -> List [ Dict [ str , Any ]]: \"\"\"Return the Embeds attached to this Session.\"\"\" query = gql ( \"\"\" query getEmbeds($handle: String!) { sessionByHandle(handle: $handle) { embeds { key embed { id contentType created contentHash owner { username } url } } } } \"\"\" ) result = self . _gqlclient . execute ( query , variable_values = { \"handle\" : self . _session_id } ) assert ( \"sessionByHandle\" in result and isinstance ( result [ \"sessionByHandle\" ], dict ) and isinstance ( result [ \"sessionByHandle\" ][ \"embeds\" ], list ) ) return result [ \"sessionByHandle\" ][ \"embeds\" ] def get_messages ( self ) -> List [ Dict [ str , Any ]]: \"\"\"Return the messages that make up this session.\"\"\" query = gql ( \"\"\" query getMessages($handle: String!) { sessionByHandle(handle: $handle) { messages { id text sentBy { handle } type inReplyTo { id } timestamp } } } \"\"\" ) result = self . _gqlclient . execute ( query , variable_values = { \"handle\" : self . _session_id } ) assert ( \"sessionByHandle\" in result and isinstance ( result [ \"sessionByHandle\" ], dict ) and isinstance ( result [ \"sessionByHandle\" ][ \"messages\" ], list ) ) return result [ \"sessionByHandle\" ][ \"messages\" ] def add_message ( self , text : str ) -> str : \"\"\"Add a message to this Session. Returns the added message text.\"\"\" query = gql ( \"\"\" mutation Post($handle: String!, $text: String!) { sendSessionMessage(messageData: {session: $handle, text: $text}) { message { text } } } \"\"\" ) result = self . _gqlclient . execute ( query , variable_values = { \"handle\" : self . _session_id , \"text\" : text } ) assert isinstance ( result [ \"sendSessionMessage\" ][ \"message\" ][ \"text\" ], str ) return result [ \"sendSessionMessage\" ][ \"message\" ][ \"text\" ] def query ( self , text : str ) -> str : \"\"\"Run a single query against the Fixie API and return the response.\"\"\" self . add_message ( text ) # The reply to the query comes in as the most recent 'response' message in the # session. response = self . get_messages ()[ - 1 ] assert isinstance ( response [ \"text\" ], str ) return response [ \"text\" ] def run ( self , text : str ) -> Generator [ Dict [ str , Any ], None , None ]: \"\"\"Run a query against the Fixie API, returning a generator that yields messages.\"\"\" # Run the query in the background, and continue polling for replies. background_client = self . clone () threading . Thread ( target = background_client . add_message , args = ( text ,)) . start () response_received = False while not response_received : time . sleep ( 1 ) messages = self . get_messages_since_last_time () for message in messages : response_received = message [ \"type\" ] == \"response\" yield message def get_messages_since_last_time ( self ) -> List [ Dict [ str , Any ]]: \"\"\"Return all messages since the given timestamp.\"\"\" timestamp = self . _last_message_timestamp messages_since_last_time = [] for message in self . get_messages (): message_timestamp = datetime . datetime . fromisoformat ( message [ \"timestamp\" ]) if timestamp is None or message_timestamp > timestamp : messages_since_last_time . append ( message ) self . _last_message_timestamp = message_timestamp return messages_since_last_time","title":"Session"},{"location":"python-client-api/#fixieai.client.session.Session.frontend_agent_id","text":"Return the frontend agent ID used by this Fixie client.","title":"frontend_agent_id"},{"location":"python-client-api/#fixieai.client.session.Session.session_id","text":"Return the session ID used by this Fixie client.","title":"session_id"},{"location":"python-client-api/#fixieai.client.session.Session.session_url","text":"Return the URL of the Fixie session.","title":"session_url"},{"location":"python-client-api/#fixieai.client.session.Session.add_message","text":"Add a message to this Session. Returns the added message text. Source code in fixieai/client/session.py 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 def add_message ( self , text : str ) -> str : \"\"\"Add a message to this Session. Returns the added message text.\"\"\" query = gql ( \"\"\" mutation Post($handle: String!, $text: String!) { sendSessionMessage(messageData: {session: $handle, text: $text}) { message { text } } } \"\"\" ) result = self . _gqlclient . execute ( query , variable_values = { \"handle\" : self . _session_id , \"text\" : text } ) assert isinstance ( result [ \"sendSessionMessage\" ][ \"message\" ][ \"text\" ], str ) return result [ \"sendSessionMessage\" ][ \"message\" ][ \"text\" ]","title":"add_message()"},{"location":"python-client-api/#fixieai.client.session.Session.clone","text":"Return a new Session instance with the same configuration. Source code in fixieai/client/session.py 64 65 66 def clone ( self ) -> \"Session\" : \"\"\"Return a new Session instance with the same configuration.\"\"\" return Session ( self . _client . clone (), session_id = self . _session_id )","title":"clone()"},{"location":"python-client-api/#fixieai.client.session.Session.delete_session","text":"Delete the current session. Source code in fixieai/client/session.py 120 121 122 123 124 125 126 127 128 129 130 131 132 133 def delete_session ( self ) -> None : \"\"\"Delete the current session.\"\"\" query = gql ( \"\"\" mutation DeleteSession($handle: String!) { deleteSession(handle: $handle) { session { handle } } } \"\"\" ) _ = self . _gqlclient . execute ( query , variable_values = { \"handle\" : self . _session_id })","title":"delete_session()"},{"location":"python-client-api/#fixieai.client.session.Session.get_embeds","text":"Return the Embeds attached to this Session. Source code in fixieai/client/session.py 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 def get_embeds ( self ) -> List [ Dict [ str , Any ]]: \"\"\"Return the Embeds attached to this Session.\"\"\" query = gql ( \"\"\" query getEmbeds($handle: String!) { sessionByHandle(handle: $handle) { embeds { key embed { id contentType created contentHash owner { username } url } } } } \"\"\" ) result = self . _gqlclient . execute ( query , variable_values = { \"handle\" : self . _session_id } ) assert ( \"sessionByHandle\" in result and isinstance ( result [ \"sessionByHandle\" ], dict ) and isinstance ( result [ \"sessionByHandle\" ][ \"embeds\" ], list ) ) return result [ \"sessionByHandle\" ][ \"embeds\" ]","title":"get_embeds()"},{"location":"python-client-api/#fixieai.client.session.Session.get_messages","text":"Return the messages that make up this session. Source code in fixieai/client/session.py 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 def get_messages ( self ) -> List [ Dict [ str , Any ]]: \"\"\"Return the messages that make up this session.\"\"\" query = gql ( \"\"\" query getMessages($handle: String!) { sessionByHandle(handle: $handle) { messages { id text sentBy { handle } type inReplyTo { id } timestamp } } } \"\"\" ) result = self . _gqlclient . execute ( query , variable_values = { \"handle\" : self . _session_id } ) assert ( \"sessionByHandle\" in result and isinstance ( result [ \"sessionByHandle\" ], dict ) and isinstance ( result [ \"sessionByHandle\" ][ \"messages\" ], list ) ) return result [ \"sessionByHandle\" ][ \"messages\" ]","title":"get_messages()"},{"location":"python-client-api/#fixieai.client.session.Session.get_messages_since_last_time","text":"Return all messages since the given timestamp. Source code in fixieai/client/session.py 242 243 244 245 246 247 248 249 250 251 def get_messages_since_last_time ( self ) -> List [ Dict [ str , Any ]]: \"\"\"Return all messages since the given timestamp.\"\"\" timestamp = self . _last_message_timestamp messages_since_last_time = [] for message in self . get_messages (): message_timestamp = datetime . datetime . fromisoformat ( message [ \"timestamp\" ]) if timestamp is None or message_timestamp > timestamp : messages_since_last_time . append ( message ) self . _last_message_timestamp = message_timestamp return messages_since_last_time","title":"get_messages_since_last_time()"},{"location":"python-client-api/#fixieai.client.session.Session.get_metadata","text":"Return metadata about this session. Source code in fixieai/client/session.py 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 def get_metadata ( self ) -> Dict [ str , Any ]: \"\"\"Return metadata about this session.\"\"\" query = gql ( \"\"\" query getSession($session_id: String!) { sessionByHandle(handle: $session_id) { handle name description frontendAgentId } } \"\"\" ) result = self . _gqlclient . execute ( query , variable_values = { \"session_id\" : self . _session_id } ) assert \"sessionByHandle\" in result and isinstance ( result [ \"sessionByHandle\" ], dict ) self . _frontend_agent_id = result [ \"sessionByHandle\" ][ \"frontendAgentId\" ] return result [ \"sessionByHandle\" ]","title":"get_metadata()"},{"location":"python-client-api/#fixieai.client.session.Session.query","text":"Run a single query against the Fixie API and return the response. Source code in fixieai/client/session.py 217 218 219 220 221 222 223 224 def query ( self , text : str ) -> str : \"\"\"Run a single query against the Fixie API and return the response.\"\"\" self . add_message ( text ) # The reply to the query comes in as the most recent 'response' message in the # session. response = self . get_messages ()[ - 1 ] assert isinstance ( response [ \"text\" ], str ) return response [ \"text\" ]","title":"query()"},{"location":"python-client-api/#fixieai.client.session.Session.run","text":"Run a query against the Fixie API, returning a generator that yields messages. Source code in fixieai/client/session.py 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 def run ( self , text : str ) -> Generator [ Dict [ str , Any ], None , None ]: \"\"\"Run a query against the Fixie API, returning a generator that yields messages.\"\"\" # Run the query in the background, and continue polling for replies. background_client = self . clone () threading . Thread ( target = background_client . add_message , args = ( text ,)) . start () response_received = False while not response_received : time . sleep ( 1 ) messages = self . get_messages_since_last_time () for message in messages : response_received = message [ \"type\" ] == \"response\" yield message","title":"run()"},{"location":"python-client-api/#fixieai.client.agent.Agent","text":"Provides an interface to the Fixie GraphQL Agent API. Parameters: Name Type Description Default client FixieClient The FixieClient instance to use. required agent_id str The Agent ID, e.g., \"fixie/calc\", or handle, e.g., \"dice\". required Source code in fixieai/client/agent.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 class Agent : \"\"\"Provides an interface to the Fixie GraphQL Agent API. Args: client: The FixieClient instance to use. agent_id: The Agent ID, e.g., \"fixie/calc\", or handle, e.g., \"dice\". \"\"\" def __init__ ( self , client : FixieClient , agent_id : str , ): self . _client = client self . _gqlclient = self . _client . gqlclient self . _agent_id = agent_id self . _owner : Optional [ str ] = None if \"/\" in agent_id : self . _owner , self . _handle = agent_id . split ( \"/\" ) else : self . _handle = agent_id self . _metadata : Optional [ Dict [ str , Any ]] = None try : self . _metadata = self . get_metadata () except : self . _metadata = None @property def agent_id ( self ) -> str : \"\"\"Return the agentId for this Agent.\"\"\" return self . _agent_id @property def handle ( self ) -> str : \"\"\"Return the handle for this Agent.\"\"\" return self . _handle @property def valid ( self ) -> bool : \"\"\"Return whether this Agent is valid.\"\"\" return self . _metadata is not None @property def name ( self ) -> Optional [ str ]: \"\"\"Return the name for this Agent.\"\"\" if self . _metadata is None : return None name = self . _metadata [ \"name\" ] assert name is None or isinstance ( name , str ) return name @property def description ( self ) -> Optional [ str ]: \"\"\"Return the description for this Agent.\"\"\" if self . _metadata is None : return None description = self . _metadata [ \"description\" ] assert description is None or isinstance ( description , str ) return description @property def queries ( self ) -> Optional [ List [ str ]]: \"\"\"Return the queries for this Agent.\"\"\" if self . _metadata is None : return None queries = self . _metadata [ \"queries\" ] assert queries is None or ( isinstance ( queries , list ) and all ( isinstance ( q , str ) for q in queries ) ) return queries @property def more_info_url ( self ) -> Optional [ str ]: \"\"\"Return the more info URL for this Agent.\"\"\" if self . _metadata is None : return None more_info_url = self . _metadata [ \"moreInfoUrl\" ] assert more_info_url is None or isinstance ( more_info_url , str ) return more_info_url @property def published ( self ) -> Optional [ bool ]: \"\"\"Return the published status for this Agent.\"\"\" if self . _metadata is None : return None published = self . _metadata [ \"published\" ] assert published is None or isinstance ( published , bool ) return published @property def owner ( self ) -> Optional [ str ]: \"\"\"Return the owner of this Agent.\"\"\" if self . _metadata is None : return None owner_username = self . _metadata [ \"owner\" ][ \"username\" ] assert owner_username is None or isinstance ( owner_username , str ) return owner_username @property def query_url ( self ) -> Optional [ str ]: \"\"\"Return the query URL for this Agent.\"\"\" if self . _metadata is None : return None url = self . _metadata [ \"queryUrl\" ] assert url is None or isinstance ( url , str ) return url @property def func_url ( self ) -> Optional [ str ]: \"\"\"Return the func URL for this Agent.\"\"\" if self . _metadata is None : return None url = self . _metadata [ \"funcUrl\" ] assert url is None or isinstance ( url , str ) return url @property def created ( self ) -> Optional [ datetime . datetime ]: \"\"\"Return the creation timestamp for this Agent.\"\"\" if self . _metadata is None : return None ts = self . _metadata [ \"created\" ] if ts is not None : return datetime . datetime . fromisoformat ( ts ) else : return None @property def modified ( self ) -> Optional [ datetime . datetime ]: \"\"\"Return the modification timestamp for this Agent.\"\"\" if self . _metadata is None : return None ts = self . _metadata [ \"modified\" ] if ts is not None : return datetime . datetime . fromisoformat ( ts ) else : return None def get_metadata ( self ) -> Dict [ str , Any ]: \"\"\"Return metadata about this Agent.\"\"\" if self . _owner is None : # Query by handle. query = gql ( \"\"\" query getAgentByHandle($handle: String!) { agentByHandle(handle: $handle) { agentId handle name description queries moreInfoUrl published owner { username } queryUrl funcUrl created modified } } \"\"\" ) result = self . _gqlclient . execute ( query , variable_values = { \"handle\" : self . _handle } ) if \"agentByHandle\" not in result or result [ \"agentByHandle\" ] is None : raise ValueError ( f \"Cannot fetch agent metadata for { self . _handle } \" ) agent_dict = result [ \"agentByHandle\" ] else : # Query by agent ID. query = gql ( \"\"\" query getAgentById($agentId: String!) { agentById(agentId: $agentId) { agentId handle name description queries moreInfoUrl published owner { username } queryUrl funcUrl created modified } } \"\"\" ) result = self . _gqlclient . execute ( query , variable_values = { \"agentId\" : f \" { self . _owner } / { self . _handle } \" } ) if \"agentById\" not in result or result [ \"agentById\" ] is None : raise ValueError ( f \"Cannot fetch agent metadata for { self . _owner } / { self . _handle } \" ) agent_dict = result [ \"agentById\" ] assert isinstance ( agent_dict , dict ) and all ( isinstance ( k , str ) for k in agent_dict . keys () ) return agent_dict def create_agent ( self , name : Optional [ str ], description : str , query_url : Optional [ str ] = None , func_url : Optional [ str ] = None , more_info_url : Optional [ str ] = None , published : Optional [ bool ] = None , ) -> str : \"\"\"Create a new Agent with the given parameters.\"\"\" query = gql ( \"\"\" mutation CreateAgent( $handle: String!, $name: String, $description: String!, $queryUrl: String, $funcUrl: String, $moreInfoUrl: String, $published: Boolean) { createAgent( agentData: { handle: $handle, name: $name, description: $description, queryUrl: $queryUrl, funcUrl: $funcUrl, moreInfoUrl: $moreInfoUrl, published: $published } ) { agent { agentId } } } \"\"\" ) variable_values : Dict [ str , Any ] = { \"handle\" : self . _handle } if name is not None : variable_values [ \"name\" ] = name variable_values [ \"description\" ] = description if query_url is not None : variable_values [ \"queryUrl\" ] = query_url if func_url is not None : variable_values [ \"funcUrl\" ] = func_url if more_info_url is not None : variable_values [ \"moreInfoUrl\" ] = more_info_url if published is not None : variable_values [ \"published\" ] = published result = self . _gqlclient . execute ( query , variable_values = variable_values ) if \"createAgent\" not in result or result [ \"createAgent\" ] is None : raise ValueError ( f \"Failed to create Agent\" ) assert isinstance ( result [ \"createAgent\" ], dict ) assert isinstance ( result [ \"createAgent\" ][ \"agent\" ], dict ) assert isinstance ( result [ \"createAgent\" ][ \"agent\" ][ \"agentId\" ], str ) self . _metadata = self . get_metadata () return result [ \"createAgent\" ][ \"agent\" ][ \"agentId\" ] def update_agent ( self , new_handle : Optional [ str ] = None , name : Optional [ str ] = None , description : Optional [ str ] = None , query_url : Optional [ str ] = None , func_url : Optional [ str ] = None , more_info_url : Optional [ str ] = None , published : Optional [ bool ] = None , ) -> str : \"\"\"Update the Agent with the given parameters.\"\"\" query = gql ( \"\"\" mutation UpdateAgent( $handle: String!, $newHandle: String, $name: String, $description: String, $queryUrl: String, $funcUrl: String, $moreInfoUrl: String, $published: Boolean) { updateAgent( agentData: { handle: $handle, newHandle: $newHandle, name: $name, description: $description, queryUrl: $queryUrl, funcUrl: $funcUrl, moreInfoUrl: $moreInfoUrl, published: $published } ) { agent { agentId } } } \"\"\" ) variable_values : Dict [ str , Any ] = { \"handle\" : self . _handle } if new_handle is not None : variable_values [ \"newHandle\" ] = new_handle if name is not None : variable_values [ \"name\" ] = name if description is not None : variable_values [ \"description\" ] = description if query_url is not None : variable_values [ \"queryUrl\" ] = query_url if func_url is not None : variable_values [ \"funcUrl\" ] = func_url if more_info_url is not None : variable_values [ \"moreInfoUrl\" ] = more_info_url if published is not None : variable_values [ \"published\" ] = published result = self . _gqlclient . execute ( query , variable_values = variable_values ) if \"updateAgent\" not in result or result [ \"updateAgent\" ] is None : raise ValueError ( f \"Failed to update Agent\" ) assert isinstance ( result [ \"updateAgent\" ], dict ) assert isinstance ( result [ \"updateAgent\" ][ \"agent\" ], dict ) assert isinstance ( result [ \"updateAgent\" ][ \"agent\" ][ \"agentId\" ], str ) self . _metadata = self . get_metadata () if new_handle : self . _handle = new_handle return result [ \"updateAgent\" ][ \"agent\" ][ \"agentId\" ] def delete_agent ( self ) -> None : \"\"\"Delete this Agent.\"\"\" query = gql ( \"\"\" mutation DeleteAgent($handle: String!) { deleteAgent(handle: $handle) { agent { handle } } } \"\"\" ) _ = self . _gqlclient . execute ( query , variable_values = { \"handle\" : self . _handle })","title":"Agent"},{"location":"python-client-api/#fixieai.client.agent.Agent.agent_id","text":"Return the agentId for this Agent.","title":"agent_id"},{"location":"python-client-api/#fixieai.client.agent.Agent.created","text":"Return the creation timestamp for this Agent.","title":"created"},{"location":"python-client-api/#fixieai.client.agent.Agent.description","text":"Return the description for this Agent.","title":"description"},{"location":"python-client-api/#fixieai.client.agent.Agent.func_url","text":"Return the func URL for this Agent.","title":"func_url"},{"location":"python-client-api/#fixieai.client.agent.Agent.handle","text":"Return the handle for this Agent.","title":"handle"},{"location":"python-client-api/#fixieai.client.agent.Agent.modified","text":"Return the modification timestamp for this Agent.","title":"modified"},{"location":"python-client-api/#fixieai.client.agent.Agent.more_info_url","text":"Return the more info URL for this Agent.","title":"more_info_url"},{"location":"python-client-api/#fixieai.client.agent.Agent.name","text":"Return the name for this Agent.","title":"name"},{"location":"python-client-api/#fixieai.client.agent.Agent.owner","text":"Return the owner of this Agent.","title":"owner"},{"location":"python-client-api/#fixieai.client.agent.Agent.published","text":"Return the published status for this Agent.","title":"published"},{"location":"python-client-api/#fixieai.client.agent.Agent.queries","text":"Return the queries for this Agent.","title":"queries"},{"location":"python-client-api/#fixieai.client.agent.Agent.query_url","text":"Return the query URL for this Agent.","title":"query_url"},{"location":"python-client-api/#fixieai.client.agent.Agent.valid","text":"Return whether this Agent is valid.","title":"valid"},{"location":"python-client-api/#fixieai.client.agent.Agent.create_agent","text":"Create a new Agent with the given parameters. Source code in fixieai/client/agent.py 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 def create_agent ( self , name : Optional [ str ], description : str , query_url : Optional [ str ] = None , func_url : Optional [ str ] = None , more_info_url : Optional [ str ] = None , published : Optional [ bool ] = None , ) -> str : \"\"\"Create a new Agent with the given parameters.\"\"\" query = gql ( \"\"\" mutation CreateAgent( $handle: String!, $name: String, $description: String!, $queryUrl: String, $funcUrl: String, $moreInfoUrl: String, $published: Boolean) { createAgent( agentData: { handle: $handle, name: $name, description: $description, queryUrl: $queryUrl, funcUrl: $funcUrl, moreInfoUrl: $moreInfoUrl, published: $published } ) { agent { agentId } } } \"\"\" ) variable_values : Dict [ str , Any ] = { \"handle\" : self . _handle } if name is not None : variable_values [ \"name\" ] = name variable_values [ \"description\" ] = description if query_url is not None : variable_values [ \"queryUrl\" ] = query_url if func_url is not None : variable_values [ \"funcUrl\" ] = func_url if more_info_url is not None : variable_values [ \"moreInfoUrl\" ] = more_info_url if published is not None : variable_values [ \"published\" ] = published result = self . _gqlclient . execute ( query , variable_values = variable_values ) if \"createAgent\" not in result or result [ \"createAgent\" ] is None : raise ValueError ( f \"Failed to create Agent\" ) assert isinstance ( result [ \"createAgent\" ], dict ) assert isinstance ( result [ \"createAgent\" ][ \"agent\" ], dict ) assert isinstance ( result [ \"createAgent\" ][ \"agent\" ][ \"agentId\" ], str ) self . _metadata = self . get_metadata () return result [ \"createAgent\" ][ \"agent\" ][ \"agentId\" ]","title":"create_agent()"},{"location":"python-client-api/#fixieai.client.agent.Agent.delete_agent","text":"Delete this Agent. Source code in fixieai/client/agent.py 358 359 360 361 362 363 364 365 366 367 368 369 370 371 def delete_agent ( self ) -> None : \"\"\"Delete this Agent.\"\"\" query = gql ( \"\"\" mutation DeleteAgent($handle: String!) { deleteAgent(handle: $handle) { agent { handle } } } \"\"\" ) _ = self . _gqlclient . execute ( query , variable_values = { \"handle\" : self . _handle })","title":"delete_agent()"},{"location":"python-client-api/#fixieai.client.agent.Agent.get_metadata","text":"Return metadata about this Agent. Source code in fixieai/client/agent.py 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 def get_metadata ( self ) -> Dict [ str , Any ]: \"\"\"Return metadata about this Agent.\"\"\" if self . _owner is None : # Query by handle. query = gql ( \"\"\" query getAgentByHandle($handle: String!) { agentByHandle(handle: $handle) { agentId handle name description queries moreInfoUrl published owner { username } queryUrl funcUrl created modified } } \"\"\" ) result = self . _gqlclient . execute ( query , variable_values = { \"handle\" : self . _handle } ) if \"agentByHandle\" not in result or result [ \"agentByHandle\" ] is None : raise ValueError ( f \"Cannot fetch agent metadata for { self . _handle } \" ) agent_dict = result [ \"agentByHandle\" ] else : # Query by agent ID. query = gql ( \"\"\" query getAgentById($agentId: String!) { agentById(agentId: $agentId) { agentId handle name description queries moreInfoUrl published owner { username } queryUrl funcUrl created modified } } \"\"\" ) result = self . _gqlclient . execute ( query , variable_values = { \"agentId\" : f \" { self . _owner } / { self . _handle } \" } ) if \"agentById\" not in result or result [ \"agentById\" ] is None : raise ValueError ( f \"Cannot fetch agent metadata for { self . _owner } / { self . _handle } \" ) agent_dict = result [ \"agentById\" ] assert isinstance ( agent_dict , dict ) and all ( isinstance ( k , str ) for k in agent_dict . keys () ) return agent_dict","title":"get_metadata()"},{"location":"python-client-api/#fixieai.client.agent.Agent.update_agent","text":"Update the Agent with the given parameters. Source code in fixieai/client/agent.py 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 def update_agent ( self , new_handle : Optional [ str ] = None , name : Optional [ str ] = None , description : Optional [ str ] = None , query_url : Optional [ str ] = None , func_url : Optional [ str ] = None , more_info_url : Optional [ str ] = None , published : Optional [ bool ] = None , ) -> str : \"\"\"Update the Agent with the given parameters.\"\"\" query = gql ( \"\"\" mutation UpdateAgent( $handle: String!, $newHandle: String, $name: String, $description: String, $queryUrl: String, $funcUrl: String, $moreInfoUrl: String, $published: Boolean) { updateAgent( agentData: { handle: $handle, newHandle: $newHandle, name: $name, description: $description, queryUrl: $queryUrl, funcUrl: $funcUrl, moreInfoUrl: $moreInfoUrl, published: $published } ) { agent { agentId } } } \"\"\" ) variable_values : Dict [ str , Any ] = { \"handle\" : self . _handle } if new_handle is not None : variable_values [ \"newHandle\" ] = new_handle if name is not None : variable_values [ \"name\" ] = name if description is not None : variable_values [ \"description\" ] = description if query_url is not None : variable_values [ \"queryUrl\" ] = query_url if func_url is not None : variable_values [ \"funcUrl\" ] = func_url if more_info_url is not None : variable_values [ \"moreInfoUrl\" ] = more_info_url if published is not None : variable_values [ \"published\" ] = published result = self . _gqlclient . execute ( query , variable_values = variable_values ) if \"updateAgent\" not in result or result [ \"updateAgent\" ] is None : raise ValueError ( f \"Failed to update Agent\" ) assert isinstance ( result [ \"updateAgent\" ], dict ) assert isinstance ( result [ \"updateAgent\" ][ \"agent\" ], dict ) assert isinstance ( result [ \"updateAgent\" ][ \"agent\" ][ \"agentId\" ], str ) self . _metadata = self . get_metadata () if new_handle : self . _handle = new_handle return result [ \"updateAgent\" ][ \"agent\" ][ \"agentId\" ]","title":"update_agent()"},{"location":"python-client-api/#fixieai.cli.cli.fixie","text":"Command-line interface to the Fixie platform. Source code in fixieai/cli/cli.py 34 35 36 37 38 @click . group () @click . pass_context def fixie ( ctx ): \"\"\"Command-line interface to the Fixie platform.\"\"\" ctx . ensure_object ( CliContext )","title":"fixie()"},{"location":"python-client-api/#fixieai.cli.session.console.Console","text":"A simple console interface for Fixie. Source code in fixieai/cli/session/console.py 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 class Console : \"\"\"A simple console interface for Fixie.\"\"\" def __init__ ( self , client : FixieClient , session : Session , history_file : str = HISTORY_FILE , ): self . _client = client self . _session = session history_file = os . path . expanduser ( history_file ) os . makedirs ( os . path . dirname ( history_file ), exist_ok = True ) self . _history_file = history_file self . _response_index = 0 def run ( self , initial_message : Optional [ str ] = None , ) -> None : \"\"\"Run the console application.\"\"\" textconsole . print ( \"[blue]Welcome to Fixie!\" ) textconsole . print ( f \"Connected to: { self . _session . session_url } \" ) # Show what's already in the session thus far. for message in self . _session . get_messages_since_last_time (): self . _show_message ( message , show_user_message = True ) history = prompt_toolkit . history . FileHistory ( self . _history_file ) if initial_message : prompt_toolkit . print_formatted_text ( f \" { PROMPT }{ initial_message } \" ) history . append_string ( initial_message ) self . _query ( initial_message ) while True : in_text = prompt_toolkit . prompt ( PROMPT , history = history , auto_suggest = prompt_toolkit . auto_suggest . AutoSuggestFromHistory (), ) self . _query ( in_text ) def _query ( self , in_text : str ) -> None : with textconsole . status ( \"Working...\" , spinner = \"bouncingBall\" ): try : for message in self . _session . run ( in_text ): self . _show_message ( message ) except requests . exceptions . HTTPError as e : textconsole . print ( f \"\ud83d\udea8 { e } \" ) return def _show_message ( self , message : Dict [ str , Any ], show_user_message : bool = False ): \"\"\"Shows a message dict from FixieClient. If show_user_message is set, the user messages are also printed with the PROMPT. This option is useful for showing previous messages in the chat when connecting to a session. \"\"\" sender_handle = ( message [ \"sentBy\" ][ \"handle\" ] if message [ \"sentBy\" ] else \"<unknown>\" ) if message [ \"type\" ] == \"query\" and sender_handle == \"user\" : if show_user_message : textconsole . print ( f \" { PROMPT }{ markup . escape ( message [ 'text' ]) } \" ) elif message [ \"type\" ] != \"response\" : textconsole . print ( f \" [dim]@ { sender_handle } : { markup . escape ( message [ 'text' ]) } [/]\" ) else : self . _response_index += 1 textconsole . print ( f \" { self . _response_index } \u276f { markup . escape ( message [ 'text' ]) } \" ) self . _show_embeds ( message [ \"text\" ]) def _show_embeds ( self , message : str ): \"\"\"Shows embeds referenced in `message_text`.\"\"\" # Check embed references in message (denoted by #id). embed_ids = _extract_embed_refs ( message ) if not embed_ids : return # Get a dict of all embed_id -> embeds in the session. embeds = { embed_dict [ \"key\" ]: embed_dict [ \"embed\" ] for embed_dict in self . _session . get_embeds () } # Show what we can find. for embed_id in embed_ids : if embed_id not in embeds : textconsole . print ( f \" [dim]embed # { embed_id } not found in session[/]\" , style = \"red\" ) continue _show_embed ( embeds [ embed_id ][ \"url\" ], embeds [ embed_id ][ \"contentType\" ], )","title":"Console"},{"location":"python-client-api/#fixieai.cli.session.console.Console.run","text":"Run the console application. Source code in fixieai/cli/session/console.py 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 def run ( self , initial_message : Optional [ str ] = None , ) -> None : \"\"\"Run the console application.\"\"\" textconsole . print ( \"[blue]Welcome to Fixie!\" ) textconsole . print ( f \"Connected to: { self . _session . session_url } \" ) # Show what's already in the session thus far. for message in self . _session . get_messages_since_last_time (): self . _show_message ( message , show_user_message = True ) history = prompt_toolkit . history . FileHistory ( self . _history_file ) if initial_message : prompt_toolkit . print_formatted_text ( f \" { PROMPT }{ initial_message } \" ) history . append_string ( initial_message ) self . _query ( initial_message ) while True : in_text = prompt_toolkit . prompt ( PROMPT , history = history , auto_suggest = prompt_toolkit . auto_suggest . AutoSuggestFromHistory (), ) self . _query ( in_text )","title":"run()"}]}